{
  "version": 3,
  "sources": ["../../../node_modules/@dimforge/rapier2d/src/exports.ts", "../../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js", "../../../node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.js", "../../../node_modules/@dimforge/rapier2d/src/math.ts", "../../../node_modules/@dimforge/rapier2d/src/dynamics/rigid_body.ts", "../../../node_modules/@dimforge/rapier2d/src/coarena.ts", "../../../node_modules/@dimforge/rapier2d/src/dynamics/rigid_body_set.ts", "../../../node_modules/@dimforge/rapier2d/src/dynamics/integration_parameters.ts", "../../../node_modules/@dimforge/rapier2d/src/dynamics/impulse_joint.ts", "../../../node_modules/@dimforge/rapier2d/src/dynamics/impulse_joint_set.ts", "../../../node_modules/@dimforge/rapier2d/src/dynamics/multibody_joint.ts", "../../../node_modules/@dimforge/rapier2d/src/dynamics/multibody_joint_set.ts", "../../../node_modules/@dimforge/rapier2d/src/dynamics/coefficient_combine_rule.ts", "../../../node_modules/@dimforge/rapier2d/src/dynamics/ccd_solver.ts", "../../../node_modules/@dimforge/rapier2d/src/dynamics/island_manager.ts", "../../../node_modules/@dimforge/rapier2d/src/geometry/broad_phase.ts", "../../../node_modules/@dimforge/rapier2d/src/geometry/narrow_phase.ts", "../../../node_modules/@dimforge/rapier2d/src/geometry/contact.ts", "../../../node_modules/@dimforge/rapier2d/src/geometry/feature.ts", "../../../node_modules/@dimforge/rapier2d/src/geometry/point.ts", "../../../node_modules/@dimforge/rapier2d/src/geometry/ray.ts", "../../../node_modules/@dimforge/rapier2d/src/geometry/toi.ts", "../../../node_modules/@dimforge/rapier2d/src/geometry/shape.ts", "../../../node_modules/@dimforge/rapier2d/src/pipeline/physics_pipeline.ts", "../../../node_modules/@dimforge/rapier2d/src/pipeline/query_pipeline.ts", "../../../node_modules/@dimforge/rapier2d/src/pipeline/serialization_pipeline.ts", "../../../node_modules/@dimforge/rapier2d/src/pipeline/debug_render_pipeline.ts", "../../../node_modules/@dimforge/rapier2d/src/control/character_controller.ts", "../../../node_modules/@dimforge/rapier2d/src/pipeline/world.ts", "../../../node_modules/@dimforge/rapier2d/src/pipeline/event_queue.ts", "../../../node_modules/@dimforge/rapier2d/src/pipeline/physics_hooks.ts", "../../../node_modules/@dimforge/rapier2d/src/geometry/collider.ts", "../../../node_modules/@dimforge/rapier2d/src/geometry/collider_set.ts", "../../../node_modules/@dimforge/rapier2d/src/rapier.ts"],
  "sourcesContent": ["import {version as vers} from \"./raw\";\n\nexport function version(): string {\n    return vers();\n}\n\nexport * from \"./math\";\nexport * from \"./dynamics\";\nexport * from \"./geometry\";\nexport * from \"./pipeline\";\nexport * from \"./init\";\nexport * from \"./control\";\n", "import * as wasm from \"./rapier_wasm2d_bg.wasm\";\nimport { __wbg_set_wasm } from \"./rapier_wasm2d_bg.js\";\n__wbg_set_wasm(wasm);\nexport * from \"./rapier_wasm2d_bg.js\";\n", "let wasm;\nexport function __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedFloat64Memory0 = null;\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n/**\n* @returns {string}\n*/\nexport function version() {\n    let deferred1_0;\n    let deferred1_1;\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.version(retptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        deferred1_0 = r0;\n        deferred1_1 = r1;\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n    }\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nlet cachedFloat32Memory0 = null;\n\nfunction getFloat32Memory0() {\n    if (cachedFloat32Memory0 === null || cachedFloat32Memory0.byteLength === 0) {\n        cachedFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32Memory0;\n}\n\nlet stack_pointer = 128;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet cachedUint32Memory0 = null;\n\nfunction getUint32Memory0() {\n    if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {\n        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getFloat32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n*/\nexport const RawShapeType = Object.freeze({ Ball:0,\"0\":\"Ball\",Cuboid:1,\"1\":\"Cuboid\",Capsule:2,\"2\":\"Capsule\",Segment:3,\"3\":\"Segment\",Polyline:4,\"4\":\"Polyline\",Triangle:5,\"5\":\"Triangle\",TriMesh:6,\"6\":\"TriMesh\",HeightField:7,\"7\":\"HeightField\",Compound:8,\"8\":\"Compound\",ConvexPolygon:9,\"9\":\"ConvexPolygon\",RoundCuboid:10,\"10\":\"RoundCuboid\",RoundTriangle:11,\"11\":\"RoundTriangle\",RoundConvexPolygon:12,\"12\":\"RoundConvexPolygon\",HalfSpace:13,\"13\":\"HalfSpace\", });\n/**\n*/\nexport const RawFeatureType = Object.freeze({ Vertex:0,\"0\":\"Vertex\",Face:1,\"1\":\"Face\",Unknown:2,\"2\":\"Unknown\", });\n/**\n*/\nexport const RawRigidBodyType = Object.freeze({ Dynamic:0,\"0\":\"Dynamic\",Fixed:1,\"1\":\"Fixed\",KinematicPositionBased:2,\"2\":\"KinematicPositionBased\",KinematicVelocityBased:3,\"3\":\"KinematicVelocityBased\", });\n/**\n*/\nexport const RawJointType = Object.freeze({ Revolute:0,\"0\":\"Revolute\",Fixed:1,\"1\":\"Fixed\",Prismatic:2,\"2\":\"Prismatic\",Rope:3,\"3\":\"Rope\",Spring:4,\"4\":\"Spring\",Generic:5,\"5\":\"Generic\", });\n/**\n*/\nexport const RawJointAxis = Object.freeze({ X:0,\"0\":\"X\",Y:1,\"1\":\"Y\",AngX:2,\"2\":\"AngX\", });\n/**\n*/\nexport const RawMotorModel = Object.freeze({ AccelerationBased:0,\"0\":\"AccelerationBased\",ForceBased:1,\"1\":\"ForceBased\", });\n/**\n*/\nexport class RawBroadPhase {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawBroadPhase.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawbroadphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawbroadphase_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n}\n/**\n*/\nexport class RawCCDSolver {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawccdsolver_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawccdsolver_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n}\n/**\n*/\nexport class RawCharacterCollision {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcharactercollision_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawcharactercollision_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {number}\n    */\n    handle() {\n        const ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    translationDeltaApplied() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    translationDeltaRemaining() {\n        const ret = wasm.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawcharactercollision_toi(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldWitness1() {\n        const ret = wasm.rawcharactercollision_worldWitness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldWitness2() {\n        const ret = wasm.rawcharactercollision_worldWitness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldNormal1() {\n        const ret = wasm.rawcharactercollision_worldNormal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldNormal2() {\n        const ret = wasm.rawcharactercollision_worldNormal2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawColliderSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawColliderSet.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcolliderset_free(ptr);\n    }\n    /**\n    * The world-space translation of this collider.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    coTranslation(handle) {\n        const ret = wasm.rawcolliderset_coTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this collider.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    coRotation(handle) {\n        const ret = wasm.rawcolliderset_coRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this collider.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the collider along the `x` axis.\n    * - `y`: the world-space position of the collider along the `y` axis.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    */\n    coSetTranslation(handle, x, y) {\n        wasm.rawcolliderset_coSetTranslation(this.__wbg_ptr, handle, x, y);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    */\n    coSetTranslationWrtParent(handle, x, y) {\n        wasm.rawcolliderset_coSetTranslationWrtParent(this.__wbg_ptr, handle, x, y);\n    }\n    /**\n    * Sets the rotation angle of this collider.\n    *\n    * # Parameters\n    * - `angle`: the rotation angle, in radians.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} angle\n    */\n    coSetRotation(handle, angle) {\n        wasm.rawcolliderset_coSetRotation(this.__wbg_ptr, handle, angle);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} angle\n    */\n    coSetRotationWrtParent(handle, angle) {\n        wasm.rawcolliderset_coSetRotationWrtParent(this.__wbg_ptr, handle, angle);\n    }\n    /**\n    * Is this collider a sensor?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    coIsSensor(handle) {\n        const ret = wasm.rawcolliderset_coIsSensor(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The type of the shape of this collider.\n    * @param {number} handle\n    * @returns {RawShapeType}\n    */\n    coShapeType(handle) {\n        const ret = wasm.rawcolliderset_coShapeType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHalfspaceNormal(handle) {\n        const ret = wasm.rawcolliderset_coHalfspaceNormal(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The half-extents of this collider if it is has a cuboid shape.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHalfExtents(handle) {\n        const ret = wasm.rawcolliderset_coHalfExtents(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * Set the half-extents of this collider if it has a cuboid shape.\n    * @param {number} handle\n    * @param {RawVector} newHalfExtents\n    */\n    coSetHalfExtents(handle, newHalfExtents) {\n        _assertClass(newHalfExtents, RawVector);\n        wasm.rawcolliderset_coSetHalfExtents(this.__wbg_ptr, handle, newHalfExtents.__wbg_ptr);\n    }\n    /**\n    * The radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRadius(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @param {number} newRadius\n    */\n    coSetRadius(handle, newRadius) {\n        wasm.rawcolliderset_coSetRadius(this.__wbg_ptr, handle, newRadius);\n    }\n    /**\n    * The half height of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHalfHeight(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHalfHeight(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the half height of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @param {number} newHalfheight\n    */\n    coSetHalfHeight(handle, newHalfheight) {\n        wasm.rawcolliderset_coSetHalfHeight(this.__wbg_ptr, handle, newHalfheight);\n    }\n    /**\n    * The radius of the round edges of this collider.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRoundRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRoundRadius(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the radius of the round edges of this collider.\n    * @param {number} handle\n    * @param {number} newBorderRadius\n    */\n    coSetRoundRadius(handle, newBorderRadius) {\n        wasm.rawcolliderset_coSetRoundRadius(this.__wbg_ptr, handle, newBorderRadius);\n    }\n    /**\n    * The vertices of this triangle mesh, polyline, convex polyhedron, segment, triangle or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coVertices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coVertices(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The indices of this triangle mesh, polyline, or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Uint32Array | undefined}\n    */\n    coIndices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coIndices(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayU32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coTriMeshFlags(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coTriMeshFlags(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The height of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coHeightfieldHeights(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldHeights(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The scaling factor applied of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHeightfieldScale(handle) {\n        const ret = wasm.rawcolliderset_coHeightfieldScale(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The unique integer identifier of the collider this collider is attached to.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coParent(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coParent(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    coSetEnabled(handle, enabled) {\n        wasm.rawcolliderset_coSetEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    coIsEnabled(handle) {\n        const ret = wasm.rawcolliderset_coIsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} contact_skin\n    */\n    coSetContactSkin(handle, contact_skin) {\n        wasm.rawcolliderset_coSetContactSkin(this.__wbg_ptr, handle, contact_skin);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coContactSkin(handle) {\n        const ret = wasm.rawcolliderset_coContactSkin(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The friction coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFriction(handle) {\n        const ret = wasm.rawcolliderset_coFriction(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The restitution coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coRestitution(handle) {\n        const ret = wasm.rawcolliderset_coRestitution(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The density of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coDensity(handle) {\n        const ret = wasm.rawcolliderset_coDensity(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The mass of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coMass(handle) {\n        const ret = wasm.rawcolliderset_coMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The volume of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coVolume(handle) {\n        const ret = wasm.rawcolliderset_coVolume(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The collision groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coCollisionGroups(handle) {\n        const ret = wasm.rawcolliderset_coCollisionGroups(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The solver groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coSolverGroups(handle) {\n        const ret = wasm.rawcolliderset_coSolverGroups(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The physics hooks enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveHooks(handle) {\n        const ret = wasm.rawcolliderset_coActiveHooks(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The collision types enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveCollisionTypes(handle) {\n        const ret = wasm.rawcolliderset_coActiveCollisionTypes(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The events enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveEvents(handle) {\n        const ret = wasm.rawcolliderset_coActiveEvents(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The total force magnitude beyond which a contact force event can be emitted.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coContactForceEventThreshold(handle) {\n        const ret = wasm.rawcolliderset_coContactForceEventThreshold(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n    coContainsPoint(handle, point) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coContainsPoint(this.__wbg_ptr, handle, point.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} colliderVel\n    * @param {RawShape} shape2\n    * @param {RawVector} shape2Pos\n    * @param {RawRotation} shape2Rot\n    * @param {RawVector} shape2Vel\n    * @param {number} target_distance\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeCastHit | undefined}\n    */\n    coCastShape(handle, colliderVel, shape2, shape2Pos, shape2Rot, shape2Vel, target_distance, maxToi, stop_at_penetration) {\n        _assertClass(colliderVel, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shape2Pos, RawVector);\n        _assertClass(shape2Rot, RawRotation);\n        _assertClass(shape2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastShape(this.__wbg_ptr, handle, colliderVel.__wbg_ptr, shape2.__wbg_ptr, shape2Pos.__wbg_ptr, shape2Rot.__wbg_ptr, shape2Vel.__wbg_ptr, target_distance, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeCastHit.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} collider1Vel\n    * @param {number} collider2handle\n    * @param {RawVector} collider2Vel\n    * @param {number} target_distance\n    * @param {number} max_toi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawColliderShapeCastHit | undefined}\n    */\n    coCastCollider(handle, collider1Vel, collider2handle, collider2Vel, target_distance, max_toi, stop_at_penetration) {\n        _assertClass(collider1Vel, RawVector);\n        _assertClass(collider2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastCollider(this.__wbg_ptr, handle, collider1Vel.__wbg_ptr, collider2handle, collider2Vel.__wbg_ptr, target_distance, max_toi, stop_at_penetration);\n        return ret === 0 ? undefined : RawColliderShapeCastHit.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n    coIntersectsShape(handle, shape2, shapePos2, shapeRot2) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coIntersectsShape(this.__wbg_ptr, handle, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    coContactShape(handle, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coContactShape(this.__wbg_ptr, handle, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} collider2handle\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    coContactCollider(handle, collider2handle, prediction) {\n        const ret = wasm.rawcolliderset_coContactCollider(this.__wbg_ptr, handle, collider2handle, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n    coProjectPoint(handle, point, solid) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coProjectPoint(this.__wbg_ptr, handle, point.__wbg_ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n    coIntersectsRay(handle, rayOrig, rayDir, maxToi) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coIntersectsRay(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n    coCastRay(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRay(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n    coCastRayAndGetNormal(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRayAndGetNormal(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} is_sensor\n    */\n    coSetSensor(handle, is_sensor) {\n        wasm.rawcolliderset_coSetSensor(this.__wbg_ptr, handle, is_sensor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} restitution\n    */\n    coSetRestitution(handle, restitution) {\n        wasm.rawcolliderset_coSetRestitution(this.__wbg_ptr, handle, restitution);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} friction\n    */\n    coSetFriction(handle, friction) {\n        wasm.rawcolliderset_coSetFriction(this.__wbg_ptr, handle, friction);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFrictionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coFrictionCombineRule(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetFrictionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetFrictionCombineRule(this.__wbg_ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coRestitutionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coRestitutionCombineRule(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetRestitutionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetRestitutionCombineRule(this.__wbg_ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetCollisionGroups(handle, groups) {\n        wasm.rawcolliderset_coSetCollisionGroups(this.__wbg_ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetSolverGroups(handle, groups) {\n        wasm.rawcolliderset_coSetSolverGroups(this.__wbg_ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} hooks\n    */\n    coSetActiveHooks(handle, hooks) {\n        wasm.rawcolliderset_coSetActiveHooks(this.__wbg_ptr, handle, hooks);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} events\n    */\n    coSetActiveEvents(handle, events) {\n        wasm.rawcolliderset_coSetActiveEvents(this.__wbg_ptr, handle, events);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} types\n    */\n    coSetActiveCollisionTypes(handle, types) {\n        wasm.rawcolliderset_coSetActiveCollisionTypes(this.__wbg_ptr, handle, types);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape\n    */\n    coSetShape(handle, shape) {\n        _assertClass(shape, RawShape);\n        wasm.rawcolliderset_coSetShape(this.__wbg_ptr, handle, shape.__wbg_ptr);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} threshold\n    */\n    coSetContactForceEventThreshold(handle, threshold) {\n        wasm.rawcolliderset_coSetContactForceEventThreshold(this.__wbg_ptr, handle, threshold);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} density\n    */\n    coSetDensity(handle, density) {\n        wasm.rawcolliderset_coSetDensity(this.__wbg_ptr, handle, density);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    */\n    coSetMass(handle, mass) {\n        wasm.rawcolliderset_coSetMass(this.__wbg_ptr, handle, mass);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {number} principalAngularInertia\n    */\n    coSetMassProperties(handle, mass, centerOfMass, principalAngularInertia) {\n        _assertClass(centerOfMass, RawVector);\n        wasm.rawcolliderset_coSetMassProperties(this.__wbg_ptr, handle, mass, centerOfMass.__wbg_ptr, principalAngularInertia);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawcolliderset_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawcolliderset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {boolean} enabled\n    * @param {RawShape} shape\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {number} massPropsMode\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {number} principalAngularInertia\n    * @param {number} density\n    * @param {number} friction\n    * @param {number} restitution\n    * @param {number} frictionCombineRule\n    * @param {number} restitutionCombineRule\n    * @param {boolean} isSensor\n    * @param {number} collisionGroups\n    * @param {number} solverGroups\n    * @param {number} activeCollisionTypes\n    * @param {number} activeHooks\n    * @param {number} activeEvents\n    * @param {number} contactForceEventThreshold\n    * @param {number} contactSkin\n    * @param {boolean} hasParent\n    * @param {number} parent\n    * @param {RawRigidBodySet} bodies\n    * @returns {number | undefined}\n    */\n    createCollider(enabled, shape, translation, rotation, massPropsMode, mass, centerOfMass, principalAngularInertia, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, contactSkin, hasParent, parent, bodies) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(shape, RawShape);\n            _assertClass(translation, RawVector);\n            _assertClass(rotation, RawRotation);\n            _assertClass(centerOfMass, RawVector);\n            _assertClass(bodies, RawRigidBodySet);\n            wasm.rawcolliderset_createCollider(retptr, this.__wbg_ptr, enabled, shape.__wbg_ptr, translation.__wbg_ptr, rotation.__wbg_ptr, massPropsMode, mass, centerOfMass.__wbg_ptr, principalAngularInertia, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, contactSkin, hasParent, parent, bodies.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Removes a collider from this set and wake-up the rigid-body it is attached to.\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawRigidBodySet} bodies\n    * @param {boolean} wakeUp\n    */\n    remove(handle, islands, bodies, wakeUp) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(bodies, RawRigidBodySet);\n        wasm.rawcolliderset_remove(this.__wbg_ptr, handle, islands.__wbg_ptr, bodies.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Checks if a collider with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    isHandleValid(handle) {\n        const ret = wasm.rawcolliderset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each collider managed by this collider set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each collider managed by this collider set. Called as `f(handle)`.\n    * @param {Function} f\n    */\n    forEachColliderHandle(f) {\n        try {\n            wasm.rawcolliderset_forEachColliderHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawColliderShapeCastHit {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawColliderShapeCastHit.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcollidershapecasthit_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawcollidershapecasthit_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    time_of_impact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness1() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness2() {\n        const ret = wasm.rawcollidershapecasthit_witness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawcollidershapecasthit_normal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawcollidershapecasthit_normal2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawContactForceEvent {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactForceEvent.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactforceevent_free(ptr);\n    }\n    /**\n    * The first collider involved in the contact.\n    * @returns {number}\n    */\n    collider1() {\n        const ret = wasm.rawcollidershapecasthit_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The second collider involved in the contact.\n    * @returns {number}\n    */\n    collider2() {\n        const ret = wasm.rawcontactforceevent_collider2(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The sum of all the forces between the two colliders.\n    * @returns {RawVector}\n    */\n    total_force() {\n        const ret = wasm.rawcontactforceevent_total_force(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The sum of the magnitudes of each force between the two colliders.\n    *\n    * Note that this is **not** the same as the magnitude of `self.total_force`.\n    * Here we are summing the magnitude of all the forces, instead of taking\n    * the magnitude of their sum.\n    * @returns {number}\n    */\n    total_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The world-space (unit) direction of the force with strongest magnitude.\n    * @returns {RawVector}\n    */\n    max_force_direction() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The magnitude of the largest force at a contact point of this contact pair.\n    * @returns {number}\n    */\n    max_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawContactManifold {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactManifold.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactmanifold_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawcontactmanifold_normal(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n1() {\n        const ret = wasm.rawcontactmanifold_local_n1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n2() {\n        const ret = wasm.rawcontactmanifold_local_n2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    subshape1() {\n        const ret = wasm.rawcontactmanifold_subshape1(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    subshape2() {\n        const ret = wasm.rawcontactmanifold_subshape2(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    num_contacts() {\n        const ret = wasm.rawcontactmanifold_num_contacts(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p1(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p1(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p2(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p2(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_contact_dist(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid1(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid1(this.__wbg_ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid2(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid2(this.__wbg_ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_impulse(i) {\n        const ret = wasm.rawcontactmanifold_contact_impulse(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_tangent_impulse(i) {\n        const ret = wasm.rawcontactmanifold_contact_tangent_impulse(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    num_solver_contacts() {\n        const ret = wasm.rawcontactmanifold_num_solver_contacts(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    solver_contact_point(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_point(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_dist(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_friction(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_friction(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_restitution(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_restitution(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector}\n    */\n    solver_contact_tangent_velocity(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_tangent_velocity(this.__wbg_ptr, i);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawContactPair {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactPair.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactpair_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    collider1() {\n        const ret = wasm.rawcontactpair_collider1(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    collider2() {\n        const ret = wasm.rawcontactpair_collider2(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    numContactManifolds() {\n        const ret = wasm.rawcontactpair_numContactManifolds(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawContactManifold | undefined}\n    */\n    contactManifold(i) {\n        const ret = wasm.rawcontactpair_contactManifold(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawContactManifold.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawDebugRenderPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdebugrenderpipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawdebugrenderpipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    vertices() {\n        const ret = wasm.rawdebugrenderpipeline_vertices(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    colors() {\n        const ret = wasm.rawdebugrenderpipeline_colors(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} impulse_joints\n    * @param {RawMultibodyJointSet} multibody_joints\n    * @param {RawNarrowPhase} narrow_phase\n    */\n    render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        _assertClass(narrow_phase, RawNarrowPhase);\n        wasm.rawdebugrenderpipeline_render(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, impulse_joints.__wbg_ptr, multibody_joints.__wbg_ptr, narrow_phase.__wbg_ptr);\n    }\n}\n/**\n*/\nexport class RawDeserializedWorld {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawDeserializedWorld.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdeserializedworld_free(ptr);\n    }\n    /**\n    * @returns {RawVector | undefined}\n    */\n    takeGravity() {\n        const ret = wasm.rawdeserializedworld_takeGravity(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawIntegrationParameters | undefined}\n    */\n    takeIntegrationParameters() {\n        const ret = wasm.rawdeserializedworld_takeIntegrationParameters(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawIntegrationParameters.__wrap(ret);\n    }\n    /**\n    * @returns {RawIslandManager | undefined}\n    */\n    takeIslandManager() {\n        const ret = wasm.rawdeserializedworld_takeIslandManager(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawIslandManager.__wrap(ret);\n    }\n    /**\n    * @returns {RawBroadPhase | undefined}\n    */\n    takeBroadPhase() {\n        const ret = wasm.rawdeserializedworld_takeBroadPhase(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawBroadPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawNarrowPhase | undefined}\n    */\n    takeNarrowPhase() {\n        const ret = wasm.rawdeserializedworld_takeNarrowPhase(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawNarrowPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawRigidBodySet | undefined}\n    */\n    takeBodies() {\n        const ret = wasm.rawdeserializedworld_takeBodies(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawRigidBodySet.__wrap(ret);\n    }\n    /**\n    * @returns {RawColliderSet | undefined}\n    */\n    takeColliders() {\n        const ret = wasm.rawdeserializedworld_takeColliders(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawColliderSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawImpulseJointSet | undefined}\n    */\n    takeImpulseJoints() {\n        const ret = wasm.rawdeserializedworld_takeImpulseJoints(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawImpulseJointSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawMultibodyJointSet | undefined}\n    */\n    takeMultibodyJoints() {\n        const ret = wasm.rawdeserializedworld_takeMultibodyJoints(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawMultibodyJointSet.__wrap(ret);\n    }\n}\n/**\n* A structure responsible for collecting events generated\n* by the physics engine.\n*/\nexport class RawEventQueue {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_raweventqueue_free(ptr);\n    }\n    /**\n    * Creates a new event collector.\n    *\n    * # Parameters\n    * - `autoDrain`: setting this to `true` is strongly recommended. If true, the collector will\n    * be automatically drained before each `world.step(collector)`. If false, the collector will\n    * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n    * RAM if no drain is performed.\n    * @param {boolean} autoDrain\n    */\n    constructor(autoDrain) {\n        const ret = wasm.raweventqueue_new(autoDrain);\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * Applies the given javascript closure on each collision event of this collector, then clear\n    * the internal collision event buffer.\n    *\n    * # Parameters\n    * - `f(handle1, handle2, started)`:  JavaScript closure applied to each collision event. The\n    * closure should take three arguments: two integers representing the handles of the colliders\n    * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n    * (false).\n    * @param {Function} f\n    */\n    drainCollisionEvents(f) {\n        try {\n            wasm.raweventqueue_drainCollisionEvents(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {Function} f\n    */\n    drainContactForceEvents(f) {\n        try {\n            wasm.raweventqueue_drainContactForceEvents(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Removes all events contained by this collector.\n    */\n    clear() {\n        wasm.raweventqueue_clear(this.__wbg_ptr);\n    }\n}\n/**\n*/\nexport class RawGenericJoint {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawGenericJoint.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawgenericjoint_free(ptr);\n    }\n    /**\n    * @param {number} rest_length\n    * @param {number} stiffness\n    * @param {number} damping\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint}\n    */\n    static spring(rest_length, stiffness, damping, anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_spring(rest_length, stiffness, damping, anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * @param {number} length\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint}\n    */\n    static rope(length, anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_rope(length, anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Prismatic joint.\n    *\n    * A prismatic joint removes all the degrees of freedom between the\n    * affected bodies, except for the translation along one axis.\n    *\n    * Returns `None` if any of the provided axes cannot be normalized.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis\n    * @param {boolean} limitsEnabled\n    * @param {number} limitsMin\n    * @param {number} limitsMax\n    * @returns {RawGenericJoint | undefined}\n    */\n    static prismatic(anchor1, anchor2, axis, limitsEnabled, limitsMin, limitsMax) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_prismatic(anchor1.__wbg_ptr, anchor2.__wbg_ptr, axis.__wbg_ptr, limitsEnabled, limitsMin, limitsMax);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Fixed joint.\n    *\n    * A fixed joint removes all the degrees of freedom between the affected bodies.\n    * @param {RawVector} anchor1\n    * @param {RawRotation} axes1\n    * @param {RawVector} anchor2\n    * @param {RawRotation} axes2\n    * @returns {RawGenericJoint}\n    */\n    static fixed(anchor1, axes1, anchor2, axes2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(axes1, RawRotation);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axes2, RawRotation);\n        const ret = wasm.rawgenericjoint_fixed(anchor1.__wbg_ptr, axes1.__wbg_ptr, anchor2.__wbg_ptr, axes2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Create a new joint descriptor that builds Revolute joints.\n    *\n    * A revolute joint removes all degrees of freedom between the affected\n    * bodies except for the rotation.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint | undefined}\n    */\n    static revolute(anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_revolute(anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawImpulseJointSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawImpulseJointSet.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawimpulsejointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {RawJointType}\n    */\n    jointType(handle) {\n        const ret = wasm.rawimpulsejointset_jointType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The unique integer identifier of the first rigid-body this joint it attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle1(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle1(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The unique integer identifier of the second rigid-body this joint is attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle2(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle2(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular part of the joints local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX1(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX1(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joints local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX2(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX2(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor1(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor1(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor2(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor2(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Sets the position of the first local anchor\n    * @param {number} handle\n    * @param {RawVector} newPos\n    */\n    jointSetAnchor1(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor1(this.__wbg_ptr, handle, newPos.__wbg_ptr);\n    }\n    /**\n    * Sets the position of the second local anchor\n    * @param {number} handle\n    * @param {RawVector} newPos\n    */\n    jointSetAnchor2(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor2(this.__wbg_ptr, handle, newPos.__wbg_ptr);\n    }\n    /**\n    * Are contacts between the rigid-bodies attached by this joint enabled?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawimpulsejointset_jointContactsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawimpulsejointset_jointSetContactsEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {boolean}\n    */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsEnabled(this.__wbg_ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMin(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMax(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * Enables and sets the joint limits\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} min\n    * @param {number} max\n    */\n    jointSetLimits(handle, axis, min, max) {\n        wasm.rawimpulsejointset_jointSetLimits(this.__wbg_ptr, handle, axis, min, max);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {RawMotorModel} model\n    */\n    jointConfigureMotorModel(handle, axis, model) {\n        wasm.rawimpulsejointset_jointConfigureMotorModel(this.__wbg_ptr, handle, axis, model);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} targetVel\n    * @param {number} factor\n    */\n    jointConfigureMotorVelocity(handle, axis, targetVel, factor) {\n        wasm.rawimpulsejointset_jointConfigureMotorVelocity(this.__wbg_ptr, handle, axis, targetVel, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} targetPos\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureMotorPosition(handle, axis, targetPos, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotorPosition(this.__wbg_ptr, handle, axis, targetPos, stiffness, damping);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} targetPos\n    * @param {number} targetVel\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureMotor(handle, axis, targetPos, targetVel, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotor(this.__wbg_ptr, handle, axis, targetPos, targetVel, stiffness, damping);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawimpulsejointset_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawGenericJoint} params\n    * @param {number} parent1\n    * @param {number} parent2\n    * @param {boolean} wake_up\n    * @returns {number}\n    */\n    createJoint(params, parent1, parent2, wake_up) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawimpulsejointset_createJoint(this.__wbg_ptr, params.__wbg_ptr, parent1, parent2, wake_up);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    remove(handle, wakeUp) {\n        wasm.rawimpulsejointset_remove(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawimpulsejointset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawimpulsejointset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawIntegrationParameters {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawIntegrationParameters.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawintegrationparameters_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawintegrationparameters_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {number}\n    */\n    get dt() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get erp() {\n        const ret = wasm.rawintegrationparameters_erp(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get normalizedAllowedLinearError() {\n        const ret = wasm.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get normalizedPredictionDistance() {\n        const ret = wasm.rawintegrationparameters_normalizedPredictionDistance(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get numSolverIterations() {\n        const ret = wasm.rawintegrationparameters_numSolverIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get numAdditionalFrictionIterations() {\n        const ret = wasm.rawintegrationparameters_numAdditionalFrictionIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get numInternalPgsIterations() {\n        const ret = wasm.rawintegrationparameters_numInternalPgsIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get minIslandSize() {\n        const ret = wasm.rawimpulsejointset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxCcdSubsteps() {\n        const ret = wasm.rawintegrationparameters_maxCcdSubsteps(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get lengthUnit() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} value\n    */\n    set dt(value) {\n        wasm.rawintegrationparameters_set_dt(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set erp(value) {\n        wasm.rawintegrationparameters_set_erp(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set normalizedAllowedLinearError(value) {\n        wasm.rawintegrationparameters_set_normalizedAllowedLinearError(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set normalizedPredictionDistance(value) {\n        wasm.rawintegrationparameters_set_normalizedPredictionDistance(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set numSolverIterations(value) {\n        wasm.rawintegrationparameters_set_numSolverIterations(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set numAdditionalFrictionIterations(value) {\n        wasm.rawintegrationparameters_set_numAdditionalFrictionIterations(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set numInternalPgsIterations(value) {\n        wasm.rawintegrationparameters_set_numInternalPgsIterations(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set minIslandSize(value) {\n        wasm.rawintegrationparameters_set_minIslandSize(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxCcdSubsteps(value) {\n        wasm.rawintegrationparameters_set_maxCcdSubsteps(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set lengthUnit(value) {\n        wasm.rawintegrationparameters_set_lengthUnit(this.__wbg_ptr, value);\n    }\n    /**\n    */\n    switchToStandardPgsSolver() {\n        wasm.rawintegrationparameters_switchToStandardPgsSolver(this.__wbg_ptr);\n    }\n    /**\n    */\n    switchToSmallStepsPgsSolver() {\n        wasm.rawintegrationparameters_switchToSmallStepsPgsSolver(this.__wbg_ptr);\n    }\n    /**\n    */\n    switchToSmallStepsPgsSolverWithoutWarmstart() {\n        wasm.rawintegrationparameters_switchToSmallStepsPgsSolverWithoutWarmstart(this.__wbg_ptr);\n    }\n}\n/**\n*/\nexport class RawIslandManager {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawIslandManager.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawislandmanager_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawislandmanager_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each active rigid-body\n    * managed by this island manager.\n    *\n    * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n    * the physics engine in order to save computational power. A sleeping rigid-body never moves\n    * unless it is moved manually by the user.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each active rigid-body managed by this\n    *   set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachActiveRigidBodyHandle(f) {\n        try {\n            wasm.rawislandmanager_forEachActiveRigidBodyHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawKinematicCharacterController {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawkinematiccharactercontroller_free(ptr);\n    }\n    /**\n    * @param {number} offset\n    */\n    constructor(offset) {\n        const ret = wasm.rawkinematiccharactercontroller_new(offset);\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    up() {\n        const ret = wasm.rawcollidershapecasthit_normal2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} vector\n    */\n    setUp(vector) {\n        _assertClass(vector, RawVector);\n        wasm.rawkinematiccharactercontroller_setUp(this.__wbg_ptr, vector.__wbg_ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    normalNudgeFactor() {\n        const ret = wasm.rawkinematiccharactercontroller_normalNudgeFactor(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} value\n    */\n    setNormalNudgeFactor(value) {\n        wasm.rawkinematiccharactercontroller_setNormalNudgeFactor(this.__wbg_ptr, value);\n    }\n    /**\n    * @returns {number}\n    */\n    offset() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} value\n    */\n    setOffset(value) {\n        wasm.rawkinematiccharactercontroller_setOffset(this.__wbg_ptr, value);\n    }\n    /**\n    * @returns {boolean}\n    */\n    slideEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_slideEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {boolean} enabled\n    */\n    setSlideEnabled(enabled) {\n        wasm.rawkinematiccharactercontroller_setSlideEnabled(this.__wbg_ptr, enabled);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    autostepMaxHeight() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_autostepMaxHeight(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    autostepMinWidth() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_autostepMinWidth(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {boolean | undefined}\n    */\n    autostepIncludesDynamicBodies() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepIncludesDynamicBodies(this.__wbg_ptr);\n        return ret === 0xFFFFFF ? undefined : ret !== 0;\n    }\n    /**\n    * @returns {boolean}\n    */\n    autostepEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} maxHeight\n    * @param {number} minWidth\n    * @param {boolean} includeDynamicBodies\n    */\n    enableAutostep(maxHeight, minWidth, includeDynamicBodies) {\n        wasm.rawkinematiccharactercontroller_enableAutostep(this.__wbg_ptr, maxHeight, minWidth, includeDynamicBodies);\n    }\n    /**\n    */\n    disableAutostep() {\n        wasm.rawkinematiccharactercontroller_disableAutostep(this.__wbg_ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    maxSlopeClimbAngle() {\n        const ret = wasm.rawintegrationparameters_normalizedPredictionDistance(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} angle\n    */\n    setMaxSlopeClimbAngle(angle) {\n        wasm.rawintegrationparameters_set_normalizedPredictionDistance(this.__wbg_ptr, angle);\n    }\n    /**\n    * @returns {number}\n    */\n    minSlopeSlideAngle() {\n        const ret = wasm.rawkinematiccharactercontroller_minSlopeSlideAngle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} angle\n    */\n    setMinSlopeSlideAngle(angle) {\n        wasm.rawkinematiccharactercontroller_setMinSlopeSlideAngle(this.__wbg_ptr, angle);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    snapToGroundDistance() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_snapToGroundDistance(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} distance\n    */\n    enableSnapToGround(distance) {\n        wasm.rawkinematiccharactercontroller_enableSnapToGround(this.__wbg_ptr, distance);\n    }\n    /**\n    */\n    disableSnapToGround() {\n        wasm.rawkinematiccharactercontroller_disableSnapToGround(this.__wbg_ptr);\n    }\n    /**\n    * @returns {boolean}\n    */\n    snapToGroundEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_snapToGroundEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} dt\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawQueryPipeline} queries\n    * @param {number} collider_handle\n    * @param {RawVector} desired_translation_delta\n    * @param {boolean} apply_impulses_to_dynamic_bodies\n    * @param {number | undefined} character_mass\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {Function} filter_predicate\n    */\n    computeColliderMovement(dt, bodies, colliders, queries, collider_handle, desired_translation_delta, apply_impulses_to_dynamic_bodies, character_mass, filter_flags, filter_groups, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(queries, RawQueryPipeline);\n            _assertClass(desired_translation_delta, RawVector);\n            wasm.rawkinematiccharactercontroller_computeColliderMovement(this.__wbg_ptr, dt, bodies.__wbg_ptr, colliders.__wbg_ptr, queries.__wbg_ptr, collider_handle, desired_translation_delta.__wbg_ptr, apply_impulses_to_dynamic_bodies, !isLikeNone(character_mass), isLikeNone(character_mass) ? 0 : character_mass, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @returns {RawVector}\n    */\n    computedMovement() {\n        const ret = wasm.rawkinematiccharactercontroller_computedMovement(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    computedGrounded() {\n        const ret = wasm.rawkinematiccharactercontroller_computedGrounded(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {number}\n    */\n    numComputedCollisions() {\n        const ret = wasm.rawkinematiccharactercontroller_numComputedCollisions(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @param {RawCharacterCollision} collision\n    * @returns {boolean}\n    */\n    computedCollision(i, collision) {\n        _assertClass(collision, RawCharacterCollision);\n        const ret = wasm.rawkinematiccharactercontroller_computedCollision(this.__wbg_ptr, i, collision.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawMultibodyJointSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawMultibodyJointSet.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawmultibodyjointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {RawJointType}\n    */\n    jointType(handle) {\n        const ret = wasm.rawmultibodyjointset_jointType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular part of the joints local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX1(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joints local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX2(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor1(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor2(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Are contacts between the rigid-bodies attached by this joint enabled?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawmultibodyjointset_jointContactsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawmultibodyjointset_jointSetContactsEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {boolean}\n    */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsEnabled(this.__wbg_ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMin(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMax(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawmultibodyjointset_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawGenericJoint} params\n    * @param {number} parent1\n    * @param {number} parent2\n    * @param {boolean} wakeUp\n    * @returns {number}\n    */\n    createJoint(params, parent1, parent2, wakeUp) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawmultibodyjointset_createJoint(this.__wbg_ptr, params.__wbg_ptr, parent1, parent2, wakeUp);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    remove(handle, wakeUp) {\n        wasm.rawmultibodyjointset_remove(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawmultibodyjointset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawNarrowPhase {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawNarrowPhase.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawnarrowphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawnarrowphase_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    contact_pairs_with(handle1, f) {\n        wasm.rawnarrowphase_contact_pairs_with(this.__wbg_ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {RawContactPair | undefined}\n    */\n    contact_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_contact_pair(this.__wbg_ptr, handle1, handle2);\n        return ret === 0 ? undefined : RawContactPair.__wrap(ret);\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    intersection_pairs_with(handle1, f) {\n        wasm.rawnarrowphase_intersection_pairs_with(this.__wbg_ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {boolean}\n    */\n    intersection_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_intersection_pair(this.__wbg_ptr, handle1, handle2);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawPhysicsPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawphysicspipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawphysicspipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    * @param {RawCCDSolver} ccd_solver\n    */\n    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        wasm.rawphysicspipeline_step(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr, ccd_solver.__wbg_ptr);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    * @param {RawCCDSolver} ccd_solver\n    * @param {RawEventQueue} eventQueue\n    * @param {object} hookObject\n    * @param {Function} hookFilterContactPair\n    * @param {Function} hookFilterIntersectionPair\n    */\n    stepWithEvents(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver, eventQueue, hookObject, hookFilterContactPair, hookFilterIntersectionPair) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        _assertClass(eventQueue, RawEventQueue);\n        wasm.rawphysicspipeline_stepWithEvents(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr, ccd_solver.__wbg_ptr, eventQueue.__wbg_ptr, addHeapObject(hookObject), addHeapObject(hookFilterContactPair), addHeapObject(hookFilterIntersectionPair));\n    }\n}\n/**\n*/\nexport class RawPointColliderProjection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawPointColliderProjection.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointcolliderprojection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point() {\n        const ret = wasm.rawpointcolliderprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    isInside() {\n        const ret = wasm.rawpointcolliderprojection_isInside(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {RawFeatureType}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawPointProjection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawPointProjection.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointprojection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point() {\n        const ret = wasm.rawpointprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    isInside() {\n        const ret = wasm.rawpointprojection_isInside(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawQueryPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawquerypipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawquerypipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    */\n    update(bodies, colliders) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawquerypipeline_update(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawRayColliderHit | undefined}\n    */\n    castRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRay(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderHit.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawRayColliderIntersection | undefined}\n    */\n    castRayAndGetNormal(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRayAndGetNormal(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderIntersection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            wasm.rawquerypipeline_intersectionsWithRay(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {number | undefined}\n    */\n    intersectionWithShape(bodies, colliders, shapePos, shapeRot, shape, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionWithShape(retptr, this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shape.__wbg_ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawPointColliderProjection | undefined}\n    */\n    projectPoint(bodies, colliders, point, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPoint(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawPointColliderProjection | undefined}\n    */\n    projectPointAndGetFeature(bodies, colliders, point, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPointAndGetFeature(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithPoint(bodies, colliders, point, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            wasm.rawquerypipeline_intersectionsWithPoint(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} shapeVel\n    * @param {RawShape} shape\n    * @param {number} target_distance\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawColliderShapeCastHit | undefined}\n    */\n    castShape(bodies, colliders, shapePos, shapeRot, shapeVel, shape, target_distance, maxToi, stop_at_penetration, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shapeVel, RawVector);\n            _assertClass(shape, RawShape);\n            const ret = wasm.rawquerypipeline_castShape(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shapeVel.__wbg_ptr, shape.__wbg_ptr, target_distance, maxToi, stop_at_penetration, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawColliderShapeCastHit.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithShape(bodies, colliders, shapePos, shapeRot, shape, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionsWithShape(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shape.__wbg_ptr, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawVector} aabbCenter\n    * @param {RawVector} aabbHalfExtents\n    * @param {Function} callback\n    */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        try {\n            _assertClass(aabbCenter, RawVector);\n            _assertClass(aabbHalfExtents, RawVector);\n            wasm.rawquerypipeline_collidersWithAabbIntersectingAabb(this.__wbg_ptr, aabbCenter.__wbg_ptr, aabbHalfExtents.__wbg_ptr, addBorrowedObject(callback));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawRayColliderHit {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayColliderHit.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycolliderhit_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawcollidershapecasthit_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    timeOfImpact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawRayColliderIntersection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayColliderIntersection.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycolliderintersection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    time_of_impact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawFeatureType}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawRayIntersection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayIntersection.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrayintersection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    time_of_impact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawFeatureType}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawRigidBodySet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRigidBodySet.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrigidbodyset_free(ptr);\n    }\n    /**\n    * The world-space translation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Put the given rigid-body to sleep.\n    * @param {number} handle\n    */\n    rbSleep(handle) {\n        wasm.rawrigidbodyset_rbSleep(this.__wbg_ptr, handle);\n    }\n    /**\n    * Is this rigid-body sleeping?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsSleeping(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsSleeping(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is the velocity of this rigid-body not zero?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsMoving(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsMoving(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The world-space predicted translation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbNextTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space predicted orientation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbNextRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this rigid-body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {boolean} wakeUp\n    */\n    rbSetTranslation(handle, x, y, wakeUp) {\n        wasm.rawrigidbodyset_rbSetTranslation(this.__wbg_ptr, handle, x, y, wakeUp);\n    }\n    /**\n    * Sets the rotation angle of this rigid-body.\n    *\n    * # Parameters\n    * - `angle`: the rotation angle, in radians.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} angle\n    * @param {boolean} wakeUp\n    */\n    rbSetRotation(handle, angle, wakeUp) {\n        wasm.rawrigidbodyset_rbSetRotation(this.__wbg_ptr, handle, angle, wakeUp);\n    }\n    /**\n    * Sets the linear velocity of this rigid-body.\n    * @param {number} handle\n    * @param {RawVector} linvel\n    * @param {boolean} wakeUp\n    */\n    rbSetLinvel(handle, linvel, wakeUp) {\n        _assertClass(linvel, RawVector);\n        wasm.rawrigidbodyset_rbSetLinvel(this.__wbg_ptr, handle, linvel.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Sets the angular velocity of this rigid-body.\n    * @param {number} handle\n    * @param {number} angvel\n    * @param {boolean} wakeUp\n    */\n    rbSetAngvel(handle, angvel, wakeUp) {\n        wasm.rawrigidbodyset_rbSetAngvel(this.__wbg_ptr, handle, angvel, wakeUp);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    */\n    rbSetNextKinematicTranslation(handle, x, y) {\n        wasm.rawrigidbodyset_rbSetNextKinematicTranslation(this.__wbg_ptr, handle, x, y);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `angle`: the rotation angle, in radians.\n    * @param {number} handle\n    * @param {number} angle\n    */\n    rbSetNextKinematicRotation(handle, angle) {\n        wasm.rawrigidbodyset_rbSetNextKinematicRotation(this.__wbg_ptr, handle, angle);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawColliderSet} colliders\n    */\n    rbRecomputeMassPropertiesFromColliders(handle, colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders(this.__wbg_ptr, handle, colliders.__wbg_ptr);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {boolean} wake_up\n    */\n    rbSetAdditionalMass(handle, mass, wake_up) {\n        wasm.rawrigidbodyset_rbSetAdditionalMass(this.__wbg_ptr, handle, mass, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {number} principalAngularInertia\n    * @param {boolean} wake_up\n    */\n    rbSetAdditionalMassProperties(handle, mass, centerOfMass, principalAngularInertia, wake_up) {\n        _assertClass(centerOfMass, RawVector);\n        wasm.rawrigidbodyset_rbSetAdditionalMassProperties(this.__wbg_ptr, handle, mass, centerOfMass.__wbg_ptr, principalAngularInertia, wake_up);\n    }\n    /**\n    * The linear velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbLinvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinvel(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The angular velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbAngvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngvel(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockTranslations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockTranslations(this.__wbg_ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} allow_x\n    * @param {boolean} allow_y\n    * @param {boolean} wake_up\n    */\n    rbSetEnabledTranslations(handle, allow_x, allow_y, wake_up) {\n        wasm.rawrigidbodyset_rbSetEnabledTranslations(this.__wbg_ptr, handle, allow_x, allow_y, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockRotations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockRotations(this.__wbg_ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbDominanceGroup(handle) {\n        const ret = wasm.rawrigidbodyset_rbDominanceGroup(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} group\n    */\n    rbSetDominanceGroup(handle, group) {\n        wasm.rawrigidbodyset_rbSetDominanceGroup(this.__wbg_ptr, handle, group);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    rbEnableCcd(handle, enabled) {\n        wasm.rawrigidbodyset_rbEnableCcd(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} prediction\n    */\n    rbSetSoftCcdPrediction(handle, prediction) {\n        wasm.rawrigidbodyset_rbSetSoftCcdPrediction(this.__wbg_ptr, handle, prediction);\n    }\n    /**\n    * The mass of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The inverse of the mass of a rigid-body.\n    *\n    * If this is zero, the rigid-body is assumed to have infinite mass.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The inverse mass taking into account translation locking.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbEffectiveInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveInvMass(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The center of mass of a rigid-body expressed in its local-space.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbLocalCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbLocalCom(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space center of mass of the rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbWorldCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbWorldCom(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The inverse of the principal angular inertia of the rigid-body.\n    *\n    * Components set to zero are assumed to be infinite along the corresponding principal axis.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbInvPrincipalInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvPrincipalInertiaSqrt(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular inertia along the principal inertia axes of the rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbPrincipalInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbPrincipalInertia(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n    * taking into account rotation locking.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbEffectiveWorldInvInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n    * this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbEffectiveAngularInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveAngularInertia(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * Wakes this rigid-body up.\n    *\n    * A dynamic rigid-body that does not move during several consecutive frames will\n    * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n    * to avoid useless computations.\n    * This method forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n    * the position of a dynamic body so that it is properly simulated afterwards.\n    * @param {number} handle\n    */\n    rbWakeUp(handle) {\n        wasm.rawrigidbodyset_rbWakeUp(this.__wbg_ptr, handle);\n    }\n    /**\n    * Is Continuous Collision Detection enabled for this rigid-body?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsCcdEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsCcdEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbSoftCcdPrediction(handle) {\n        const ret = wasm.rawrigidbodyset_rbSoftCcdPrediction(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The number of colliders attached to this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbNumColliders(handle) {\n        const ret = wasm.rawrigidbodyset_rbNumColliders(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Retrieves the `i-th` collider attached to this rigid-body.\n    *\n    * # Parameters\n    * - `at`: The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n    *         This index is **not** the same as the unique identifier of the collider.\n    * @param {number} handle\n    * @param {number} at\n    * @returns {number}\n    */\n    rbCollider(handle, at) {\n        const ret = wasm.rawrigidbodyset_rbCollider(this.__wbg_ptr, handle, at);\n        return ret;\n    }\n    /**\n    * The status of this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @returns {RawRigidBodyType}\n    */\n    rbBodyType(handle) {\n        const ret = wasm.rawrigidbodyset_rbBodyType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * Set a new status for this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @param {RawRigidBodyType} status\n    * @param {boolean} wake_up\n    */\n    rbSetBodyType(handle, status, wake_up) {\n        wasm.rawrigidbodyset_rbSetBodyType(this.__wbg_ptr, handle, status, wake_up);\n    }\n    /**\n    * Is this rigid-body fixed?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsFixed(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsFixed(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body kinematic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsKinematic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsKinematic(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body dynamic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsDynamic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsDynamic(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The linear damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbLinearDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinearDamping(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbAngularDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngularDamping(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetLinearDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetLinearDamping(this.__wbg_ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetAngularDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetAngularDamping(this.__wbg_ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    rbSetEnabled(handle, enabled) {\n        wasm.rawrigidbodyset_rbSetEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbGravityScale(handle) {\n        const ret = wasm.rawrigidbodyset_rbGravityScale(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    * @param {boolean} wakeUp\n    */\n    rbSetGravityScale(handle, factor, wakeUp) {\n        wasm.rawrigidbodyset_rbSetGravityScale(this.__wbg_ptr, handle, factor, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added forces added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    rbResetForces(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetForces(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added torques added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    rbResetTorques(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetTorques(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * Adds a force at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {boolean} wakeUp\n    */\n    rbAddForce(handle, force, wakeUp) {\n        _assertClass(force, RawVector);\n        wasm.rawrigidbodyset_rbAddForce(this.__wbg_ptr, handle, force.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulse(handle, impulse, wakeUp) {\n        _assertClass(impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulse(this.__wbg_ptr, handle, impulse.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Adds a torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque`: the torque to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {number} torque\n    * @param {boolean} wakeUp\n    */\n    rbAddTorque(handle, torque, wakeUp) {\n        wasm.rawrigidbodyset_rbAddTorque(this.__wbg_ptr, handle, torque, wakeUp);\n    }\n    /**\n    * Applies an impulsive torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque impulse`: the torque impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {number} torque_impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyTorqueImpulse(handle, torque_impulse, wakeUp) {\n        wasm.rawrigidbodyset_rbApplyTorqueImpulse(this.__wbg_ptr, handle, torque_impulse, wakeUp);\n    }\n    /**\n    * Adds a force at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbAddForceAtPoint(handle, force, point, wakeUp) {\n        _assertClass(force, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbAddForceAtPoint(this.__wbg_ptr, handle, force.__wbg_ptr, point.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulseAtPoint(handle, impulse, point, wakeUp) {\n        _assertClass(impulse, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulseAtPoint(this.__wbg_ptr, handle, impulse.__wbg_ptr, point.__wbg_ptr, wakeUp);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbAdditionalSolverIterations(handle) {\n        const ret = wasm.rawrigidbodyset_rbAdditionalSolverIterations(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} iters\n    */\n    rbSetAdditionalSolverIterations(handle, iters) {\n        wasm.rawrigidbodyset_rbSetAdditionalSolverIterations(this.__wbg_ptr, handle, iters);\n    }\n    /**\n    * An arbitrary user-defined 32-bit integer\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbUserData(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserData(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Sets the user-defined 32-bit integer of this rigid-body.\n    *\n    * # Parameters\n    * - `data`: an arbitrary user-defined 32-bit integer.\n    * @param {number} handle\n    * @param {number} data\n    */\n    rbSetUserData(handle, data) {\n        wasm.rawrigidbodyset_rbSetUserData(this.__wbg_ptr, handle, data);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawrigidbodyset_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {boolean} enabled\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {number} gravityScale\n    * @param {number} mass\n    * @param {boolean} massOnly\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} linvel\n    * @param {number} angvel\n    * @param {number} principalAngularInertia\n    * @param {boolean} translationEnabledX\n    * @param {boolean} translationEnabledY\n    * @param {boolean} rotationsEnabled\n    * @param {number} linearDamping\n    * @param {number} angularDamping\n    * @param {RawRigidBodyType} rb_type\n    * @param {boolean} canSleep\n    * @param {boolean} sleeping\n    * @param {number} softCcdPrediciton\n    * @param {boolean} ccdEnabled\n    * @param {number} dominanceGroup\n    * @param {number} additional_solver_iterations\n    * @returns {number}\n    */\n    createRigidBody(enabled, translation, rotation, gravityScale, mass, massOnly, centerOfMass, linvel, angvel, principalAngularInertia, translationEnabledX, translationEnabledY, rotationsEnabled, linearDamping, angularDamping, rb_type, canSleep, sleeping, softCcdPrediciton, ccdEnabled, dominanceGroup, additional_solver_iterations) {\n        _assertClass(translation, RawVector);\n        _assertClass(rotation, RawRotation);\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(linvel, RawVector);\n        const ret = wasm.rawrigidbodyset_createRigidBody(this.__wbg_ptr, enabled, translation.__wbg_ptr, rotation.__wbg_ptr, gravityScale, mass, massOnly, centerOfMass.__wbg_ptr, linvel.__wbg_ptr, angvel, principalAngularInertia, translationEnabledX, translationEnabledY, rotationsEnabled, linearDamping, angularDamping, rb_type, canSleep, sleeping, softCcdPrediciton, ccdEnabled, dominanceGroup, additional_solver_iterations);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    */\n    remove(handle, islands, colliders, joints, articulations) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        wasm.rawrigidbodyset_remove(this.__wbg_ptr, handle, islands.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr);\n    }\n    /**\n    * The number of rigid-bodies on this set.\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Checks if a rigid-body with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawrigidbodyset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each rigid-body managed by this set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each rigid-body managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachRigidBodyHandle(f) {\n        try {\n            wasm.rawrigidbodyset_forEachRigidBodyHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    */\n    propagateModifiedBodyPositionsToColliders(colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_propagateModifiedBodyPositionsToColliders(this.__wbg_ptr, colliders.__wbg_ptr);\n    }\n}\n/**\n* A rotation quaternion.\n*/\nexport class RawRotation {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRotation.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrotation_free(ptr);\n    }\n    /**\n    * The identity rotation.\n    * @returns {RawRotation}\n    */\n    static identity() {\n        const ret = wasm.rawrotation_identity();\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The rotation with thegiven angle.\n    * @param {number} angle\n    * @returns {RawRotation}\n    */\n    static fromAngle(angle) {\n        const ret = wasm.rawrotation_fromAngle(angle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The imaginary part of this complex number.\n    * @returns {number}\n    */\n    get im() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The real part of this complex number.\n    * @returns {number}\n    */\n    get re() {\n        const ret = wasm.rawrotation_re(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The rotation angle in radians.\n    * @returns {number}\n    */\n    get angle() {\n        const ret = wasm.rawrotation_angle(this.__wbg_ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawSerializationPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawserializationpipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawserializationpipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} impulse_joints\n    * @param {RawMultibodyJointSet} multibody_joints\n    * @returns {Uint8Array | undefined}\n    */\n    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulse_joints, multibody_joints) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        const ret = wasm.rawserializationpipeline_serializeAll(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, impulse_joints.__wbg_ptr, multibody_joints.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {RawDeserializedWorld | undefined}\n    */\n    deserializeAll(data) {\n        const ret = wasm.rawserializationpipeline_deserializeAll(this.__wbg_ptr, addHeapObject(data));\n        return ret === 0 ? undefined : RawDeserializedWorld.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShape {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShape.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshape_free(ptr);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @returns {RawShape}\n    */\n    static cuboid(hx, hy) {\n        const ret = wasm.rawshape_cuboid(hx, hy);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCuboid(hx, hy, borderRadius) {\n        const ret = wasm.rawshape_roundCuboid(hx, hy, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static ball(radius) {\n        const ret = wasm.rawshape_ball(radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} normal\n    * @returns {RawShape}\n    */\n    static halfspace(normal) {\n        _assertClass(normal, RawVector);\n        const ret = wasm.rawshape_halfspace(normal.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static capsule(halfHeight, radius) {\n        const ret = wasm.rawshape_capsule(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape}\n    */\n    static polyline(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_polyline(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @param {number} flags\n    * @returns {RawShape}\n    */\n    static trimesh(vertices, indices, flags) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_trimesh(ptr0, len0, ptr1, len1, flags);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} heights\n    * @param {RawVector} scale\n    * @returns {RawShape}\n    */\n    static heightfield(heights, scale) {\n        const ptr0 = passArrayF32ToWasm0(heights, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(scale, RawVector);\n        const ret = wasm.rawshape_heightfield(ptr0, len0, scale.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @returns {RawShape}\n    */\n    static segment(p1, p2) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        const ret = wasm.rawshape_segment(p1.__wbg_ptr, p2.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @returns {RawShape}\n    */\n    static triangle(p1, p2, p3) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_triangle(p1.__wbg_ptr, p2.__wbg_ptr, p3.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundTriangle(p1, p2, p3, borderRadius) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_roundTriangle(p1.__wbg_ptr, p2.__wbg_ptr, p3.__wbg_ptr, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @returns {RawShape | undefined}\n    */\n    static convexHull(points) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexHull(ptr0, len0);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexHull(points, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexHull(ptr0, len0, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @returns {RawShape | undefined}\n    */\n    static convexPolyline(vertices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexPolyline(ptr0, len0);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexPolyline(vertices, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexPolyline(ptr0, len0, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawVector} shapeVel1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {RawVector} shapeVel2\n    * @param {number} target_distance\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeCastHit | undefined}\n    */\n    castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, target_distance, maxToi, stop_at_penetration) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shapeVel1, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        _assertClass(shapeVel2, RawVector);\n        const ret = wasm.rawshape_castShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shapeVel1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, shapeVel2.__wbg_ptr, target_distance, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeCastHit.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n    intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_intersectsShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_contactShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n    containsPoint(shapePos, shapeRot, point) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_containsPoint(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, point.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n    projectPoint(shapePos, shapeRot, point, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_projectPoint(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, point.__wbg_ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n    intersectsRay(shapePos, shapeRot, rayOrig, rayDir, maxToi) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_intersectsRay(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n    castRay(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRay(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n    castRayAndGetNormal(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRayAndGetNormal(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeCastHit {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShapeCastHit.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecasthit_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    time_of_impact() {\n        const ret = wasm.rawrotation_re(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness1() {\n        const ret = wasm.rawshapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness2() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawcollidershapecasthit_witness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawcollidershapecasthit_normal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeContact {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShapeContact.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecontact_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    distance() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point1() {\n        const ret = wasm.rawpointprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point2() {\n        const ret = wasm.rawpointcolliderprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawcontactforceevent_total_force(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n* A vector.\n*/\nexport class RawVector {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawVector.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawvector_free(ptr);\n    }\n    /**\n    * Creates a new vector filled with zeros.\n    * @returns {RawVector}\n    */\n    static zero() {\n        const ret = wasm.rawvector_zero();\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Creates a new 2D vector from its two components.\n    *\n    * # Parameters\n    * - `x`: the `x` component of this 2D vector.\n    * - `y`: the `y` component of this 2D vector.\n    * @param {number} x\n    * @param {number} y\n    */\n    constructor(x, y) {\n        const ret = wasm.rawvector_new(x, y);\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * The `x` component of this vector.\n    * @returns {number}\n    */\n    get x() {\n        const ret = wasm.rawrotation_re(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Sets the `x` component of this vector.\n    * @param {number} x\n    */\n    set x(x) {\n        wasm.rawvector_set_x(this.__wbg_ptr, x);\n    }\n    /**\n    * The `y` component of this vector.\n    * @returns {number}\n    */\n    get y() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Sets the `y` component of this vector.\n    * @param {number} y\n    */\n    set y(y) {\n        wasm.rawintegrationparameters_set_dt(this.__wbg_ptr, y);\n    }\n    /**\n    * Create a new 2D vector from this vector with its components rearranged as `{x, y}`.\n    * @returns {RawVector}\n    */\n    xy() {\n        const ret = wasm.rawvector_xy(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 2D vector from this vector with its components rearranged as `{y, x}`.\n    * @returns {RawVector}\n    */\n    yx() {\n        const ret = wasm.rawvector_yx(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nexport function __wbindgen_number_new(arg0) {\n    const ret = arg0;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_boolean_get(arg0) {\n    const v = getObject(arg0);\n    const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n    return ret;\n};\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbindgen_number_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    const ret = typeof(obj) === 'number' ? obj : undefined;\n    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n};\n\nexport function __wbindgen_is_function(arg0) {\n    const ret = typeof(getObject(arg0)) === 'function';\n    return ret;\n};\n\nexport function __wbg_rawraycolliderintersection_new(arg0) {\n    const ret = RawRayColliderIntersection.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_rawcontactforceevent_new(arg0) {\n    const ret = RawContactForceEvent.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_call_01734de55d61e11d() { return handleError(function (arg0, arg1, arg2) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_4c92f6aec1e1d6e6() { return handleError(function (arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_776890ca77946e2f() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3), getObject(arg4));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_bind_60a9a80cada2f33c(arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).bind(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_buffer_085ec1f694018c4f(arg0) {\n    const ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_newwithbyteoffsetandlength_6da8e527659b86aa(arg0, arg1, arg2) {\n    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_8125e318e6245eed(arg0) {\n    const ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_5cf90238115182c3(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_72e2208bbc0efc61(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithbyteoffsetandlength_69193e31c844b792(arg0, arg1, arg2) {\n    const ret = new Float32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_6146c51d49a2c0df(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_d7327c75a759af37(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithlength_68d29ab115d0099c(arg0) {\n    const ret = new Float32Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_memory() {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n", "import {RawVector, RawRotation} from \"./raw\";\n\n// #if DIM2\nexport interface Vector {\n    x: number;\n    y: number;\n}\n\n/**\n * A 2D vector.\n */\nexport class Vector2 implements Vector {\n    x: number;\n    y: number;\n\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nexport class VectorOps {\n    public static new(x: number, y: number): Vector {\n        return new Vector2(x, y);\n    }\n\n    public static zeros(): Vector {\n        return VectorOps.new(0.0, 0.0);\n    }\n\n    // FIXME: type ram: RawVector?\n    public static fromRaw(raw: RawVector): Vector {\n        if (!raw) return null;\n\n        let res = VectorOps.new(raw.x, raw.y);\n        raw.free();\n        return res;\n    }\n\n    public static intoRaw(v: Vector): RawVector {\n        return new RawVector(v.x, v.y);\n    }\n\n    public static copy(out: Vector, input: Vector) {\n        out.x = input.x;\n        out.y = input.y;\n    }\n}\n\n/**\n * A rotation angle in radians.\n */\nexport type Rotation = number;\n\nexport class RotationOps {\n    public static identity(): number {\n        return 0.0;\n    }\n\n    public static fromRaw(raw: RawRotation): Rotation {\n        if (!raw) return null;\n\n        let res = raw.angle;\n        raw.free();\n        return res;\n    }\n\n    public static intoRaw(angle: Rotation): RawRotation {\n        return RawRotation.fromAngle(angle);\n    }\n}\n\n// #endif\n\n", "import {RawRigidBodySet, RawRigidBodyType} from \"../raw\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\nimport {Collider, ColliderSet} from \"../geometry\";\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type RigidBodyHandle = number;\n\n/**\n * The simulation status of a rigid-body.\n */\n// TODO: rename this to RigidBodyType\nexport enum RigidBodyType {\n    /**\n     * A `RigidBodyType::Dynamic` body can be affected by all external forces.\n     */\n    Dynamic = 0,\n    /**\n     * A `RigidBodyType::Fixed` body cannot be affected by external forces.\n     */\n    Fixed,\n    /**\n     * A `RigidBodyType::KinematicPositionBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the position level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    KinematicPositionBased,\n    /**\n     * A `RigidBodyType::KinematicVelocityBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the velocity level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    KinematicVelocityBased,\n}\n\n/**\n * A rigid-body.\n */\nexport class RigidBody {\n    private rawSet: RawRigidBodySet; // The RigidBody won't need to free this.\n    private colliderSet: ColliderSet;\n    readonly handle: RigidBodyHandle;\n\n    /**\n     * An arbitrary user-defined object associated with this rigid-body.\n     */\n    public userData?: unknown;\n\n    constructor(\n        rawSet: RawRigidBodySet,\n        colliderSet: ColliderSet,\n        handle: RigidBodyHandle,\n    ) {\n        this.rawSet = rawSet;\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n    }\n\n    /** @internal */\n    public finalizeDeserialization(colliderSet: ColliderSet) {\n        this.colliderSet = colliderSet;\n    }\n\n    /**\n     * Checks if this rigid-body is still valid (i.e. that it has\n     * not been deleted from the rigid-body set yet.\n     */\n    public isValid(): boolean {\n        return this.rawSet.contains(this.handle);\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer translate due to forces and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public lockTranslations(locked: boolean, wakeUp: boolean) {\n        return this.rawSet.rbLockTranslations(this.handle, locked, wakeUp);\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer rotate due to torques and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public lockRotations(locked: boolean, wakeUp: boolean) {\n        return this.rawSet.rbLockRotations(this.handle, locked, wakeUp);\n    }\n\n    // #if DIM2\n    /**\n     * Locks or unlocks the ability of this rigid-body to translation along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public setEnabledTranslations(\n        enableX: boolean,\n        enableY: boolean,\n        wakeUp: boolean,\n    ) {\n        return this.rawSet.rbSetEnabledTranslations(\n            this.handle,\n            enableX,\n            enableY,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to translation along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     * @deprecated use `this.setEnabledTranslations` with the same arguments instead.\n     */\n    public restrictTranslations(\n        enableX: boolean,\n        enableY: boolean,\n        wakeUp: boolean,\n    ) {\n        this.setEnabledTranslations(enableX, enableX, wakeUp);\n    }\n\n    // #endif\n\n    /**\n     * The dominance group, in [-127, +127] this rigid-body is part of.\n     */\n    public dominanceGroup(): number {\n        return this.rawSet.rbDominanceGroup(this.handle);\n    }\n\n    /**\n     * Sets the dominance group of this rigid-body.\n     *\n     * @param group - The dominance group of this rigid-body. Must be a signed integer in the range [-127, +127].\n     */\n    public setDominanceGroup(group: number) {\n        this.rawSet.rbSetDominanceGroup(this.handle, group);\n    }\n\n    /**\n     * The number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     */\n    public additionalSolverIterations(): number {\n        return this.rawSet.rbAdditionalSolverIterations(this.handle);\n    }\n\n    /**\n     * Sets the number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     *\n     * Compared to increasing the global `World.numSolverIteration`, setting this\n     * value lets you increase accuracy on only a subset of the scene, resulting in reduced\n     * performance loss.\n     *\n     * @param iters - The new number of additional solver iterations (default: 0).\n     */\n    public setAdditionalSolverIterations(iters: number) {\n        this.rawSet.rbSetAdditionalSolverIterations(this.handle, iters);\n    }\n\n    /**\n     * Enable or disable CCD (Continuous Collision Detection) for this rigid-body.\n     *\n     * @param enabled - If `true`, CCD will be enabled for this rigid-body.\n     */\n    public enableCcd(enabled: boolean) {\n        this.rawSet.rbEnableCcd(this.handle, enabled);\n    }\n\n    /**\n     * Sets the soft-CCD prediction distance for this rigid-body.\n     *\n     * See the documentation of `RigidBodyDesc.setSoftCcdPrediction` for\n     * additional details.\n     */\n    public setSoftCcdPrediction(distance: number) {\n        this.rawSet.rbSetSoftCcdPrediction(this.handle, distance);\n    }\n\n    /**\n     * Gets the soft-CCD prediction distance for this rigid-body.\n     *\n     * See the documentation of `RigidBodyDesc.setSoftCcdPrediction` for\n     * additional details.\n     */\n    public softCcdPrediction(): number {\n        return this.rawSet.rbSoftCcdPrediction(this.handle);\n    }\n\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    public translation(): Vector {\n        let res = this.rawSet.rbTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    public rotation(): Rotation {\n        let res = this.rawSet.rbRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n\n    /**\n     * The world-space next translation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    public nextTranslation(): Vector {\n        let res = this.rawSet.rbNextTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n\n    /**\n     * The world-space next orientation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    public nextRotation(): Rotation {\n        let res = this.rawSet.rbNextRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n\n    /**\n     * Sets the translation of this rigid-body.\n     *\n     * @param tra - The world-space position of the rigid-body.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     *                 wasn't moving before modifying its position.\n     */\n    public setTranslation(tra: Vector, wakeUp: boolean) {\n        // #if DIM2\n        this.rawSet.rbSetTranslation(this.handle, tra.x, tra.y, wakeUp);\n        // #endif\n    }\n\n    /**\n     * Sets the linear velocity of this rigid-body.\n     *\n     * @param vel - The linear velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    public setLinvel(vel: Vector, wakeUp: boolean) {\n        let rawVel = VectorOps.intoRaw(vel);\n        this.rawSet.rbSetLinvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n\n    /**\n     * The scale factor applied to the gravity affecting\n     * this rigid-body.\n     */\n    public gravityScale(): number {\n        return this.rawSet.rbGravityScale(this.handle);\n    }\n\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * this rigid-body.\n     *\n     * @param factor - The scale factor to set. A value of 0.0 means\n     *   that this rigid-body will on longer be affected by gravity.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    public setGravityScale(factor: number, wakeUp: boolean) {\n        this.rawSet.rbSetGravityScale(this.handle, factor, wakeUp);\n    }\n\n\n    // #if DIM2\n    /**\n     * Sets the rotation angle of this rigid-body.\n     *\n     * @param angle - The rotation angle, in radians.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     */\n    public setRotation(angle: number, wakeUp: boolean) {\n        this.rawSet.rbSetRotation(this.handle, angle, wakeUp);\n    }\n\n    /**\n     * Sets the angular velocity fo this rigid-body.\n     *\n     * @param vel - The angular velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    public setAngvel(vel: number, wakeUp: boolean) {\n        this.rawSet.rbSetAngvel(this.handle, vel, wakeUp);\n    }\n\n    // #endif\n\n    /**\n     * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param t - The kinematic translation to set.\n     */\n    public setNextKinematicTranslation(t: Vector) {\n        // #if DIM2\n        this.rawSet.rbSetNextKinematicTranslation(this.handle, t.x, t.y);\n        // #endif\n    }\n\n\n    // #if DIM2\n    /**\n     * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param angle - The kinematic rotation angle, in radians.\n     */\n    public setNextKinematicRotation(angle: number) {\n        this.rawSet.rbSetNextKinematicRotation(this.handle, angle);\n    }\n\n    // #endif\n\n    /**\n     * The linear velocity of this rigid-body.\n     */\n    public linvel(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbLinvel(this.handle));\n    }\n\n\n    // #if DIM2\n    /**\n     * The angular velocity of this rigid-body.\n     */\n    public angvel(): number {\n        return this.rawSet.rbAngvel(this.handle);\n    }\n\n    // #endif\n\n    /**\n     * The mass of this rigid-body.\n     */\n    public mass(): number {\n        return this.rawSet.rbMass(this.handle);\n    }\n\n    /**\n     * The inverse mass taking into account translation locking.\n     */\n    public effectiveInvMass(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbEffectiveInvMass(this.handle));\n    }\n\n    /**\n     * The inverse of the mass of a rigid-body.\n     *\n     * If this is zero, the rigid-body is assumed to have infinite mass.\n     */\n    public invMass(): number {\n        return this.rawSet.rbInvMass(this.handle);\n    }\n\n    /**\n     * The center of mass of a rigid-body expressed in its local-space.\n     */\n    public localCom(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbLocalCom(this.handle));\n    }\n\n    /**\n     * The world-space center of mass of the rigid-body.\n     */\n    public worldCom(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbWorldCom(this.handle));\n    }\n\n    // #if DIM2\n    /**\n     * The inverse of the principal angular inertia of the rigid-body.\n     *\n     * Components set to zero are assumed to be infinite along the corresponding principal axis.\n     */\n    public invPrincipalInertiaSqrt(): number {\n        return this.rawSet.rbInvPrincipalInertiaSqrt(this.handle);\n    }\n\n    // #endif\n\n\n    // #if DIM2\n    /**\n     * The angular inertia along the principal inertia axes of the rigid-body.\n     */\n    public principalInertia(): number {\n        return this.rawSet.rbPrincipalInertia(this.handle);\n    }\n\n    // #endif\n\n\n\n    // #if DIM2\n    /**\n     * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n     * taking into account rotation locking.\n     */\n    public effectiveWorldInvInertiaSqrt(): number {\n        return this.rawSet.rbEffectiveWorldInvInertiaSqrt(this.handle);\n    }\n\n    // #endif\n\n\n    // #if DIM2\n    /**\n     * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n     * this rigid-body.\n     */\n    public effectiveAngularInertia(): number {\n        return this.rawSet.rbEffectiveAngularInertia(this.handle);\n    }\n\n    // #endif\n\n\n    /**\n     * Put this rigid body to sleep.\n     *\n     * A sleeping body no longer moves and is no longer simulated by the physics engine unless\n     * it is waken up. It can be woken manually with `this.wakeUp()` or automatically due to\n     * external forces like contacts.\n     */\n    public sleep() {\n        this.rawSet.rbSleep(this.handle);\n    }\n\n    /**\n     * Wakes this rigid-body up.\n     *\n     * A dynamic rigid-body that does not move during several consecutive frames will\n     * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n     * to avoid useless computations.\n     * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n     * the position of a dynamic body so that it is properly simulated afterwards.\n     */\n    public wakeUp() {\n        this.rawSet.rbWakeUp(this.handle);\n    }\n\n    /**\n     * Is CCD enabled for this rigid-body?\n     */\n    public isCcdEnabled(): boolean {\n        return this.rawSet.rbIsCcdEnabled(this.handle);\n    }\n\n    /**\n     * The number of colliders attached to this rigid-body.\n     */\n    public numColliders(): number {\n        return this.rawSet.rbNumColliders(this.handle);\n    }\n\n    /**\n     * Retrieves the `i-th` collider attached to this rigid-body.\n     *\n     * @param i - The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n     *         This index is **not** the same as the unique identifier of the collider.\n     */\n    public collider(i: number): Collider {\n        return this.colliderSet.get(this.rawSet.rbCollider(this.handle, i));\n    }\n\n    /**\n     * Sets whether this rigid-body is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this rigid-body and all its attached colliders.\n     */\n    public setEnabled(enabled: boolean) {\n        this.rawSet.rbSetEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Is this rigid-body enabled?\n     */\n    public isEnabled(): boolean {\n        return this.rawSet.rbIsEnabled(this.handle);\n    }\n\n    /**\n     * The status of this rigid-body: static, dynamic, or kinematic.\n     */\n    public bodyType(): RigidBodyType {\n        return this.rawSet.rbBodyType(this.handle) as number as RigidBodyType;\n    }\n\n    /**\n     * Set a new status for this rigid-body: static, dynamic, or kinematic.\n     */\n    public setBodyType(type: RigidBodyType, wakeUp: boolean) {\n        return this.rawSet.rbSetBodyType(\n            this.handle,\n            type as number as RawRigidBodyType,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Is this rigid-body sleeping?\n     */\n    public isSleeping(): boolean {\n        return this.rawSet.rbIsSleeping(this.handle);\n    }\n\n    /**\n     * Is the velocity of this rigid-body not zero?\n     */\n    public isMoving(): boolean {\n        return this.rawSet.rbIsMoving(this.handle);\n    }\n\n    /**\n     * Is this rigid-body static?\n     */\n    public isFixed(): boolean {\n        return this.rawSet.rbIsFixed(this.handle);\n    }\n\n    /**\n     * Is this rigid-body kinematic?\n     */\n    public isKinematic(): boolean {\n        return this.rawSet.rbIsKinematic(this.handle);\n    }\n\n    /**\n     * Is this rigid-body dynamic?\n     */\n    public isDynamic(): boolean {\n        return this.rawSet.rbIsDynamic(this.handle);\n    }\n\n    /**\n     * The linear damping coefficient of this rigid-body.\n     */\n    public linearDamping(): number {\n        return this.rawSet.rbLinearDamping(this.handle);\n    }\n\n    /**\n     * The angular damping coefficient of this rigid-body.\n     */\n    public angularDamping(): number {\n        return this.rawSet.rbAngularDamping(this.handle);\n    }\n\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    public setLinearDamping(factor: number) {\n        this.rawSet.rbSetLinearDamping(this.handle, factor);\n    }\n\n    /**\n     * Recompute the mass-properties of this rigid-bodies based on its currently attached colliders.\n     */\n    public recomputeMassPropertiesFromColliders() {\n        this.rawSet.rbRecomputeMassPropertiesFromColliders(\n            this.handle,\n            this.colliderSet.raw,\n        );\n    }\n\n    /**\n     * Sets the rigid-body's additional mass.\n     *\n     * The total angular inertia of the rigid-body will be scaled automatically based on this additional mass. If this\n     * scaling effect isnt desired, use Self::additional_mass_properties instead of this method.\n     *\n     * This is only the \"additional\" mass because the total mass of the rigid-body is equal to the sum of this\n     * additional mass and the mass computed from the colliders (with non-zero densities) attached to this rigid-body.\n     *\n     * That total mass (which includes the attached colliders contributions) will be updated at the name physics step,\n     * or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous additional mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc::setAdditionalMass`, or\n     * `RigidBodyDesc.setAdditionalMassfProperties` for this rigid-body.\n     *\n     * @param mass - The additional mass to set.\n     * @param wakeUp - If `true` then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    public setAdditionalMass(mass: number, wakeUp: boolean) {\n        this.rawSet.rbSetAdditionalMass(this.handle, mass, wakeUp);\n    }\n\n\n    // #if DIM2\n    /**\n     * Sets the rigid-body's additional mass-properties.\n     *\n     * This is only the \"additional\" mass-properties because the total mass-properties of the rigid-body is equal to the\n     * sum of this additional mass-properties and the mass computed from the colliders (with non-zero densities) attached\n     * to this rigid-body.\n     *\n     * That total mass-properties (which include the attached colliders contributions) will be updated at the name\n     * physics step, or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc.setAdditionalMass`, or `RigidBodyDesc.setAdditionalMassProperties`\n     * for this rigid-body.\n     *\n     * If `wake_up` is true then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    public setAdditionalMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: number,\n        wakeUp: boolean,\n    ) {\n        let rawCom = VectorOps.intoRaw(centerOfMass);\n        this.rawSet.rbSetAdditionalMassProperties(\n            this.handle,\n            mass,\n            rawCom,\n            principalAngularInertia,\n            wakeUp,\n        );\n        rawCom.free();\n    }\n\n    // #endif\n\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    public setAngularDamping(factor: number) {\n        this.rawSet.rbSetAngularDamping(this.handle, factor);\n    }\n\n    /**\n     * Resets to zero the user forces (but not torques) applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public resetForces(wakeUp: boolean) {\n        this.rawSet.rbResetForces(this.handle, wakeUp);\n    }\n\n    /**\n     * Resets to zero the user torques applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public resetTorques(wakeUp: boolean) {\n        this.rawSet.rbResetTorques(this.handle, wakeUp);\n    }\n\n    /**\n     * Adds a force at the center-of-mass of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public addForce(force: Vector, wakeUp: boolean) {\n        const rawForce = VectorOps.intoRaw(force);\n        this.rawSet.rbAddForce(this.handle, rawForce, wakeUp);\n        rawForce.free();\n    }\n\n    /**\n     * Applies an impulse at the center-of-mass of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyImpulse(impulse: Vector, wakeUp: boolean) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        this.rawSet.rbApplyImpulse(this.handle, rawImpulse, wakeUp);\n        rawImpulse.free();\n    }\n\n    // #if DIM2\n    /**\n     * Adds a torque at the center-of-mass of this rigid-body.\n     *\n     * @param torque - the torque to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public addTorque(torque: number, wakeUp: boolean) {\n        this.rawSet.rbAddTorque(this.handle, torque, wakeUp);\n    }\n\n    // #endif\n\n\n    // #if DIM2\n    /**\n     * Applies an impulsive torque at the center-of-mass of this rigid-body.\n     *\n     * @param torqueImpulse - the torque impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyTorqueImpulse(torqueImpulse: number, wakeUp: boolean) {\n        this.rawSet.rbApplyTorqueImpulse(this.handle, torqueImpulse, wakeUp);\n    }\n\n    // #endif\n\n\n    /**\n     * Adds a force at the given world-space point of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public addForceAtPoint(force: Vector, point: Vector, wakeUp: boolean) {\n        const rawForce = VectorOps.intoRaw(force);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbAddForceAtPoint(this.handle, rawForce, rawPoint, wakeUp);\n        rawForce.free();\n        rawPoint.free();\n    }\n\n    /**\n     * Applies an impulse at the given world-space point of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyImpulseAtPoint(\n        impulse: Vector,\n        point: Vector,\n        wakeUp: boolean,\n    ) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbApplyImpulseAtPoint(\n            this.handle,\n            rawImpulse,\n            rawPoint,\n            wakeUp,\n        );\n        rawImpulse.free();\n        rawPoint.free();\n    }\n}\n\nexport class RigidBodyDesc {\n    enabled: boolean;\n    translation: Vector;\n    rotation: Rotation;\n    gravityScale: number;\n    mass: number;\n    massOnly: boolean;\n    centerOfMass: Vector;\n    translationsEnabledX: boolean;\n    translationsEnabledY: boolean;\n    linvel: Vector;\n    // #if DIM2\n    angvel: number;\n    principalAngularInertia: number;\n    rotationsEnabled: boolean;\n    // #endif\n    linearDamping: number;\n    angularDamping: number;\n    status: RigidBodyType;\n    canSleep: boolean;\n    sleeping: boolean;\n    ccdEnabled: boolean;\n    softCcdPrediction: number;\n    dominanceGroup: number;\n    additionalSolverIterations: number;\n    userData?: unknown;\n\n    constructor(status: RigidBodyType) {\n        this.enabled = true;\n        this.status = status;\n        this.translation = VectorOps.zeros();\n        this.rotation = RotationOps.identity();\n        this.gravityScale = 1.0;\n        this.linvel = VectorOps.zeros();\n        this.mass = 0.0;\n        this.massOnly = false;\n        this.centerOfMass = VectorOps.zeros();\n        this.translationsEnabledX = true;\n        this.translationsEnabledY = true;\n        // #if DIM2\n        this.angvel = 0.0;\n        this.principalAngularInertia = 0.0;\n        this.rotationsEnabled = true;\n        // #endif\n        this.linearDamping = 0.0;\n        this.angularDamping = 0.0;\n        this.canSleep = true;\n        this.sleeping = false;\n        this.ccdEnabled = false;\n        this.softCcdPrediction = 0.0;\n        this.dominanceGroup = 0;\n        this.additionalSolverIterations = 0;\n    }\n\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     */\n    public static dynamic(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     */\n    public static kinematicPositionBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     */\n    public static kinematicVelocityBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     */\n    public static fixed(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.dynamic()`.\n     */\n    public static newDynamic(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicPositionBased()`.\n     */\n    public static newKinematicPositionBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicVelocityBased()`.\n     */\n    public static newKinematicVelocityBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     *\n     * @deprecated The method has been renamed to `.fixed()`.\n     */\n    public static newStatic(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n\n    public setDominanceGroup(group: number): RigidBodyDesc {\n        this.dominanceGroup = group;\n        return this;\n    }\n\n    /**\n     * Sets the number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     *\n     * Compared to increasing the global `World.numSolverIteration`, setting this\n     * value lets you increase accuracy on only a subset of the scene, resulting in reduced\n     * performance loss.\n     *\n     * @param iters - The new number of additional solver iterations (default: 0).\n     */\n    public setAdditionalSolverIterations(iters: number): RigidBodyDesc {\n        this.additionalSolverIterations = iters;\n        return this;\n    }\n\n    /**\n     * Sets whether the created rigid-body will be enabled or disabled.\n     * @param enabled  If set to `false` the rigid-body will be disabled at creation.\n     */\n    public setEnabled(enabled: boolean): RigidBodyDesc {\n        this.enabled = enabled;\n        return this;\n    }\n\n    // #if DIM2\n    /**\n     * Sets the initial translation of the rigid-body to create.\n     */\n    public setTranslation(x: number, y: number): RigidBodyDesc {\n        if (typeof x != \"number\" || typeof y != \"number\")\n            throw TypeError(\"The translation components must be numbers.\");\n\n        this.translation = {x: x, y: y};\n        return this;\n    }\n\n    // #endif\n\n\n    /**\n     * Sets the initial rotation of the rigid-body to create.\n     *\n     * @param rot - The rotation to set.\n     */\n    public setRotation(rot: Rotation): RigidBodyDesc {\n        // #if DIM2\n        this.rotation = rot;\n        // #endif\n        return this;\n    }\n\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * the rigid-body being built.\n     *\n     * @param scale - The scale factor. Set this to `0.0` if the rigid-body\n     *   needs to ignore gravity.\n     */\n    public setGravityScale(scale: number): RigidBodyDesc {\n        this.gravityScale = scale;\n        return this;\n    }\n\n    /**\n     * Sets the initial mass of the rigid-body being built, before adding colliders' contributions.\n     *\n     * @param mass  The initial mass of the rigid-body to create.\n     */\n    public setAdditionalMass(mass: number): RigidBodyDesc {\n        this.mass = mass;\n        this.massOnly = true;\n        return this;\n    }\n\n    // #if DIM2\n    /**\n     * Sets the initial linear velocity of the rigid-body to create.\n     *\n     * @param x - The linear velocity to set along the `x` axis.\n     * @param y - The linear velocity to set along the `y` axis.\n     */\n    public setLinvel(x: number, y: number): RigidBodyDesc {\n        if (typeof x != \"number\" || typeof y != \"number\")\n            throw TypeError(\"The linvel components must be numbers.\");\n\n        this.linvel = {x: x, y: y};\n        return this;\n    }\n\n    /**\n     * Sets the initial angular velocity of the rigid-body to create.\n     *\n     * @param vel - The angular velocity to set.\n     */\n    public setAngvel(vel: number): RigidBodyDesc {\n        this.angvel = vel;\n        return this;\n    }\n\n    /**\n     * Sets the mass properties of the rigid-body being built.\n     *\n     * Note that the final mass properties of the rigid-bodies depends\n     * on the initial mass-properties of the rigid-body (set by this method)\n     * to which is added the contributions of all the colliders with non-zero density\n     * attached to this rigid-body.\n     *\n     * Therefore, if you want your provided mass properties to be the final\n     * mass properties of your rigid-body, don't attach colliders to it, or\n     * only attach colliders with densities equal to zero.\n     *\n     * @param mass  The initial mass of the rigid-body to create.\n     * @param centerOfMass  The initial center-of-mass of the rigid-body to create.\n     * @param principalAngularInertia  The initial principal angular inertia of the rigid-body to create.\n     */\n    public setAdditionalMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: number,\n    ): RigidBodyDesc {\n        this.mass = mass;\n        VectorOps.copy(this.centerOfMass, centerOfMass);\n        this.principalAngularInertia = principalAngularInertia;\n        this.massOnly = false;\n        return this;\n    }\n\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     */\n    public enabledTranslations(\n        translationsEnabledX: boolean,\n        translationsEnabledY: boolean,\n    ): RigidBodyDesc {\n        this.translationsEnabledX = translationsEnabledX;\n        this.translationsEnabledY = translationsEnabledY;\n        return this;\n    }\n\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     * @deprecated use `this.enabledTranslations` with the same arguments instead.\n     */\n    public restrictTranslations(\n        translationsEnabledX: boolean,\n        translationsEnabledY: boolean,\n    ): RigidBodyDesc {\n        return this.enabledTranslations(\n            translationsEnabledX,\n            translationsEnabledY,\n        );\n    }\n\n    /**\n     * Locks all translations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    public lockTranslations(): RigidBodyDesc {\n        return this.restrictTranslations(false, false);\n    }\n\n    /**\n     * Locks all rotations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    public lockRotations(): RigidBodyDesc {\n        this.rotationsEnabled = false;\n        return this;\n    }\n\n    // #endif\n\n\n    /**\n     * Sets the linear damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the translational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the translational slowdown will be.\n     */\n    public setLinearDamping(damping: number): RigidBodyDesc {\n        this.linearDamping = damping;\n        return this;\n    }\n\n    /**\n     * Sets the angular damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the rotational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the rotational slowdown will be.\n     */\n    public setAngularDamping(damping: number): RigidBodyDesc {\n        this.angularDamping = damping;\n        return this;\n    }\n\n    /**\n     * Sets whether or not the rigid-body to create can sleep.\n     *\n     * @param can - true if the rigid-body can sleep, false if it can't.\n     */\n    public setCanSleep(can: boolean): RigidBodyDesc {\n        this.canSleep = can;\n        return this;\n    }\n\n    /**\n     * Sets whether or not the rigid-body is to be created asleep.\n     *\n     * @param can - true if the rigid-body should be in sleep, default false.\n     */\n    setSleeping(sleeping: boolean): RigidBodyDesc {\n        this.sleeping = sleeping;\n        return this;\n    }\n\n    /**\n     * Sets whether Continuous Collision Detection (CCD) is enabled for this rigid-body.\n     *\n     * @param enabled - true if the rigid-body has CCD enabled.\n     */\n    public setCcdEnabled(enabled: boolean): RigidBodyDesc {\n        this.ccdEnabled = enabled;\n        return this;\n    }\n\n    /**\n     * Sets the maximum prediction distance Soft Continuous Collision-Detection.\n     *\n     * When set to 0, soft-CCD is disabled. Soft-CCD helps prevent tunneling especially of\n     * slow-but-thin to moderately fast objects. The soft CCD prediction distance indicates how\n     * far in the objects path the CCD algorithm is allowed to inspect. Large values can impact\n     * performance badly by increasing the work needed from the broad-phase.\n     *\n     * It is a generally cheaper variant of regular CCD (that can be enabled with\n     * `RigidBodyDesc::setCcdEnabled` since it relies on predictive constraints instead of\n     * shape-cast and substeps.\n     */\n    public setSoftCcdPrediction(distance: number): RigidBodyDesc {\n        this.softCcdPrediction = distance;\n        return this;\n    }\n\n    /**\n     * Sets the user-defined object of this rigid-body.\n     *\n     * @param userData - The user-defined object to set.\n     */\n    public setUserData(data?: unknown): RigidBodyDesc {\n        this.userData = data;\n        return this;\n    }\n}\n", "export class Coarena<T> {\n    fconv: Float64Array;\n    uconv: Uint32Array;\n    data: Array<T>;\n    size: number;\n\n    public constructor() {\n        this.fconv = new Float64Array(1);\n        this.uconv = new Uint32Array(this.fconv.buffer);\n        this.data = new Array<T>();\n        this.size = 0;\n    }\n\n    public set(handle: number, data: T) {\n        let i = this.index(handle);\n        while (this.data.length <= i) {\n            this.data.push(null);\n        }\n\n        if (this.data[i] == null) this.size += 1;\n        this.data[i] = data;\n    }\n\n    public len(): number {\n        return this.size;\n    }\n\n    public delete(handle: number) {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            if (this.data[i] != null) this.size -= 1;\n            this.data[i] = null;\n        }\n    }\n\n    public clear() {\n        this.data = new Array<T>();\n    }\n\n    public get(handle: number): T | null {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            return this.data[i];\n        } else {\n            return null;\n        }\n    }\n\n    public forEach(f: (elt: T) => void) {\n        for (const elt of this.data) {\n            if (elt != null) f(elt);\n        }\n    }\n\n    public getAll(): Array<T> {\n        return this.data.filter((elt) => elt != null);\n    }\n\n    private index(handle: number): number {\n        /// Extracts the index part of a handle (the lower 32 bits).\n        /// This is done by first injecting the handle into an Float64Array\n        /// which is itself injected into an Uint32Array (at construction time).\n        /// The 0-th value of the Uint32Array will become the `number` integer\n        /// representation of the lower 32 bits.\n        /// Also `this.uconv[1]` then contains the generation number as a `number`,\n        /// which we dont really need.\n        this.fconv[0] = handle;\n        return this.uconv[0];\n    }\n}\n", "import {RawRigidBodySet, RawRigidBodyType} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {VectorOps, RotationOps} from \"../math\";\nimport {\n    RigidBody,\n    RigidBodyDesc,\n    RigidBodyHandle,\n    RigidBodyType,\n} from \"./rigid_body\";\nimport {ColliderSet} from \"../geometry\";\nimport {ImpulseJointSet} from \"./impulse_joint_set\";\nimport {MultibodyJointSet} from \"./multibody_joint_set\";\nimport {IslandManager} from \"./island_manager\";\n\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `rigidBodySet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class RigidBodySet {\n    raw: RawRigidBodySet;\n    private map: Coarena<RigidBody>;\n\n    /**\n     * Release the WASM memory occupied by this rigid-body set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawRigidBodySet) {\n        this.raw = raw || new RawRigidBodySet();\n        this.map = new Coarena<RigidBody>();\n        // deserialize\n        if (raw) {\n            raw.forEachRigidBodyHandle((handle: RigidBodyHandle) => {\n                this.map.set(handle, new RigidBody(raw, null, handle));\n            });\n        }\n    }\n\n    /**\n     * Internal method, do not call this explicitly.\n     */\n    public finalizeDeserialization(colliderSet: ColliderSet) {\n        this.map.forEach((rb) => rb.finalizeDeserialization(colliderSet));\n    }\n\n    /**\n     * Creates a new rigid-body and return its integer handle.\n     *\n     * @param desc - The description of the rigid-body to create.\n     */\n    public createRigidBody(\n        colliderSet: ColliderSet,\n        desc: RigidBodyDesc,\n    ): RigidBody {\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawLv = VectorOps.intoRaw(desc.linvel);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n\n\n        let handle = this.raw.createRigidBody(\n            desc.enabled,\n            rawTra,\n            rawRot,\n            desc.gravityScale,\n            desc.mass,\n            desc.massOnly,\n            rawCom,\n            rawLv,\n            // #if DIM2\n            desc.angvel,\n            desc.principalAngularInertia,\n            desc.translationsEnabledX,\n            desc.translationsEnabledY,\n            desc.rotationsEnabled,\n            // #endif\n            desc.linearDamping,\n            desc.angularDamping,\n            desc.status as number as RawRigidBodyType,\n            desc.canSleep,\n            desc.sleeping,\n            desc.softCcdPrediction,\n            desc.ccdEnabled,\n            desc.dominanceGroup,\n            desc.additionalSolverIterations,\n        );\n\n        rawTra.free();\n        rawRot.free();\n        rawLv.free();\n        rawCom.free();\n\n\n        const body = new RigidBody(this.raw, colliderSet, handle);\n        body.userData = desc.userData;\n\n        this.map.set(handle, body);\n\n        return body;\n    }\n\n    /**\n     * Removes a rigid-body from this set.\n     *\n     * This will also remove all the colliders and joints attached to the rigid-body.\n     *\n     * @param handle - The integer handle of the rigid-body to remove.\n     * @param colliders - The set of colliders that may contain colliders attached to the removed rigid-body.\n     * @param impulseJoints - The set of impulse joints that may contain joints attached to the removed rigid-body.\n     * @param multibodyJoints - The set of multibody joints that may contain joints attached to the removed rigid-body.\n     */\n    public remove(\n        handle: RigidBodyHandle,\n        islands: IslandManager,\n        colliders: ColliderSet,\n        impulseJoints: ImpulseJointSet,\n        multibodyJoints: MultibodyJointSet,\n    ) {\n        // Unmap the entities that will be removed automatically because of the rigid-body removals.\n        for (let i = 0; i < this.raw.rbNumColliders(handle); i += 1) {\n            colliders.unmap(this.raw.rbCollider(handle, i));\n        }\n\n        impulseJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) =>\n            impulseJoints.unmap(handle),\n        );\n        multibodyJoints.forEachJointHandleAttachedToRigidBody(\n            handle,\n            (handle) => multibodyJoints.unmap(handle),\n        );\n\n        // Remove the rigid-body.\n        this.raw.remove(\n            handle,\n            islands.raw,\n            colliders.raw,\n            impulseJoints.raw,\n            multibodyJoints.raw,\n        );\n        this.map.delete(handle);\n    }\n\n    /**\n     * The number of rigid-bodies on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a rigid-body with the given handle?\n     *\n     * @param handle - The rigid-body handle to check.\n     */\n    public contains(handle: RigidBodyHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    public get(handle: RigidBodyHandle): RigidBody | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * Applies the given closure to each rigid-body contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (body: RigidBody) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Applies the given closure to each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEachActiveRigidBody(\n        islands: IslandManager,\n        f: (body: RigidBody) => void,\n    ) {\n        islands.forEachActiveRigidBodyHandle((handle) => {\n            f(this.get(handle));\n        });\n    }\n\n    /**\n     * Gets all rigid-bodies in the list.\n     *\n     * @returns rigid-bodies list.\n     */\n    public getAll(): RigidBody[] {\n        return this.map.getAll();\n    }\n}\n", "import {RawIntegrationParameters} from \"../raw\";\n\nexport class IntegrationParameters {\n    raw: RawIntegrationParameters;\n\n    constructor(raw?: RawIntegrationParameters) {\n        this.raw = raw || new RawIntegrationParameters();\n    }\n\n    /**\n     * Free the WASM memory used by these integration parameters.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    /**\n     * The timestep length (default: `1.0 / 60.0`)\n     */\n    get dt(): number {\n        return this.raw.dt;\n    }\n\n    /**\n     * The Error Reduction Parameter in `[0, 1]` is the proportion of\n     * the positional error to be corrected at each time step (default: `0.2`).\n     */\n    get erp(): number {\n        return this.raw.erp;\n    }\n\n    get lengthUnit(): number {\n        return this.raw.lengthUnit;\n    }\n\n    /**\n     * Normalized amount of penetration the engine wont attempt to correct (default: `0.001m`).\n     *\n     * This threshold considered by the physics engine is this value multiplied by the `lengthUnit`.\n     */\n    get normalizedAllowedLinearError(): number {\n        return this.raw.normalizedAllowedLinearError;\n    }\n\n    /**\n     * The maximal normalized distance separating two objects that will generate predictive contacts (default: `0.002`).\n     *\n     * This threshold considered by the physics engine is this value multiplied by the `lengthUnit`.\n     */\n    get normalizedPredictionDistance(): number {\n        return this.raw.normalizedPredictionDistance;\n    }\n\n    /**\n     * The number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    get numSolverIterations(): number {\n        return this.raw.numSolverIterations;\n    }\n\n    /**\n     * Number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    get numAdditionalFrictionIterations(): number {\n        return this.raw.numAdditionalFrictionIterations;\n    }\n\n    /**\n     * Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    get numInternalPgsIterations(): number {\n        return this.raw.numInternalPgsIterations;\n    }\n\n    /**\n     * Minimum number of dynamic bodies in each active island (default: `128`).\n     */\n    get minIslandSize(): number {\n        return this.raw.minIslandSize;\n    }\n\n    /**\n     * Maximum number of substeps performed by the  solver (default: `1`).\n     */\n    get maxCcdSubsteps(): number {\n        return this.raw.maxCcdSubsteps;\n    }\n\n    set dt(value: number) {\n        this.raw.dt = value;\n    }\n\n    set erp(value: number) {\n        this.raw.erp = value;\n    }\n\n    set lengthUnit(value: number) {\n        this.raw.lengthUnit = value;\n    }\n\n    set normalizedAllowedLinearError(value: number) {\n        this.raw.normalizedAllowedLinearError = value;\n    }\n\n    set normalizedPredictionDistance(value: number) {\n        this.raw.normalizedPredictionDistance = value;\n    }\n\n    /**\n     * Sets the number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    set numSolverIterations(value: number) {\n        this.raw.numSolverIterations = value;\n    }\n\n    /**\n     * Sets the number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    set numAdditionalFrictionIterations(value: number) {\n        this.raw.numAdditionalFrictionIterations = value;\n    }\n\n    /**\n     * Sets the number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    set numInternalPgsIterations(value: number) {\n        this.raw.numInternalPgsIterations = value;\n    }\n\n    set minIslandSize(value: number) {\n        this.raw.minIslandSize = value;\n    }\n\n    set maxCcdSubsteps(value: number) {\n        this.raw.maxCcdSubsteps = value;\n    }\n\n    public switchToStandardPgsSolver() {\n        this.raw.switchToStandardPgsSolver();\n    }\n\n    public switchToSmallStepsPgsSolver() {\n        this.raw.switchToSmallStepsPgsSolver();\n    }\n\n    public switchToSmallStepsPgsSolverWithoutWarmstart() {\n        this.raw.switchToSmallStepsPgsSolverWithoutWarmstart();\n    }\n}\n", "import {Rotation, Vector, VectorOps, RotationOps} from \"../math\";\nimport {\n    RawGenericJoint,\n    RawImpulseJointSet,\n    RawRigidBodySet,\n    RawJointAxis,\n    RawJointType,\n    RawMotorModel,\n} from \"../raw\";\nimport {RigidBody, RigidBodyHandle} from \"./rigid_body\";\nimport {RigidBodySet} from \"./rigid_body_set\";\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type ImpulseJointHandle = number;\n\n/**\n * An enum grouping all possible types of joints:\n *\n * - `Revolute`: A revolute joint that removes all degrees of freedom between the affected\n *               bodies except for the rotation along one axis.\n * - `Fixed`: A fixed joint that removes all relative degrees of freedom between the affected bodies.\n * - `Prismatic`: A prismatic joint that removes all degrees of freedom between the affected\n *                bodies except for the translation along one axis.\n * - `Spherical`: (3D only) A spherical joint that removes all relative linear degrees of freedom between the affected bodies.\n * - `Generic`: (3D only) A joint with customizable degrees of freedom, allowing any of the 6 axes to be locked.\n */\nexport enum JointType {\n    Revolute,\n    Fixed,\n    Prismatic,\n    Rope,\n    Spring,\n}\n\nexport enum MotorModel {\n    AccelerationBased,\n    ForceBased,\n}\n\n/**\n * An enum representing the possible joint axes of a generic joint.\n * They can be ORed together, like:\n * JointAxesMask.X || JointAxesMask.Y\n * to get a joint that is only free in the X and Y translational (positional) axes.\n *\n * Possible free axes are:\n *\n * - `X`: X translation axis\n * - `Y`: Y translation axis\n * - `Z`: Z translation axis\n * - `AngX`: X angular rotation axis\n * - `AngY`: Y angular rotations axis\n * - `AngZ`: Z angular rotation axis\n */\nexport enum JointAxesMask {\n    X = 1 << 0,\n    Y = 1 << 1,\n    Z = 1 << 2,\n    AngX = 1 << 3,\n    AngY = 1 << 4,\n    AngZ = 1 << 5,\n}\n\nexport class ImpulseJoint {\n    protected rawSet: RawImpulseJointSet; // The ImpulseJoint won't need to free this.\n    protected bodySet: RigidBodySet; // The ImpulseJoint wont need to free this.\n    handle: ImpulseJointHandle;\n\n    constructor(\n        rawSet: RawImpulseJointSet,\n        bodySet: RigidBodySet,\n        handle: ImpulseJointHandle,\n    ) {\n        this.rawSet = rawSet;\n        this.bodySet = bodySet;\n        this.handle = handle;\n    }\n\n    public static newTyped(\n        rawSet: RawImpulseJointSet,\n        bodySet: RigidBodySet,\n        handle: ImpulseJointHandle,\n    ): ImpulseJoint {\n        switch (rawSet.jointType(handle)) {\n            case RawJointType.Revolute:\n                return new RevoluteImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Prismatic:\n                return new PrismaticImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Fixed:\n                return new FixedImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Spring:\n                return new SpringImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Rope:\n                return new RopeImpulseJoint(rawSet, bodySet, handle);\n            default:\n                return new ImpulseJoint(rawSet, bodySet, handle);\n        }\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodySet: RigidBodySet) {\n        this.bodySet = bodySet;\n    }\n\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    public isValid(): boolean {\n        return this.rawSet.contains(this.handle);\n    }\n\n    /**\n     * The first rigid-body this joint it attached to.\n     */\n    public body1(): RigidBody {\n        return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle));\n    }\n\n    /**\n     * The second rigid-body this joint is attached to.\n     */\n    public body2(): RigidBody {\n        return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle));\n    }\n\n    /**\n     * The type of this joint given as a string.\n     */\n    public type(): JointType {\n        return this.rawSet.jointType(this.handle) as number as JointType;\n    }\n\n\n\n    /**\n     * The position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    public anchor1(): Vector {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    }\n\n    /**\n     * The position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    public anchor2(): Vector {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    }\n\n    /**\n     * Sets the position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    public setAnchor1(newPos: Vector) {\n        const rawPoint = VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor1(this.handle, rawPoint);\n        rawPoint.free();\n    }\n\n    /**\n     * Sets the position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    public setAnchor2(newPos: Vector) {\n        const rawPoint = VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor2(this.handle, rawPoint);\n        rawPoint.free();\n    }\n\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public setContactsEnabled(enabled: boolean) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public contactsEnabled(): boolean {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\n\nexport class UnitImpulseJoint extends ImpulseJoint {\n    /**\n     * The axis left free by this joint.\n     */\n    protected rawAxis?(): RawJointAxis;\n\n    /**\n     * Are the limits enabled for this joint?\n     */\n    public limitsEnabled(): boolean {\n        return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());\n    }\n\n    /**\n     * The min limit of this joint.\n     */\n    public limitsMin(): number {\n        return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());\n    }\n\n    /**\n     * The max limit of this joint.\n     */\n    public limitsMax(): number {\n        return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());\n    }\n\n    /**\n     * Sets the limits of this joint.\n     *\n     * @param min - The minimum bound of this joints free coordinate.\n     * @param max - The maximum bound of this joints free coordinate.\n     */\n    public setLimits(min: number, max: number) {\n        this.rawSet.jointSetLimits(this.handle, this.rawAxis(), min, max);\n    }\n\n    public configureMotorModel(model: MotorModel) {\n        this.rawSet.jointConfigureMotorModel(\n            this.handle,\n            this.rawAxis(),\n            model as number as RawMotorModel,\n        );\n    }\n\n    public configureMotorVelocity(targetVel: number, factor: number) {\n        this.rawSet.jointConfigureMotorVelocity(\n            this.handle,\n            this.rawAxis(),\n            targetVel,\n            factor,\n        );\n    }\n\n    public configureMotorPosition(\n        targetPos: number,\n        stiffness: number,\n        damping: number,\n    ) {\n        this.rawSet.jointConfigureMotorPosition(\n            this.handle,\n            this.rawAxis(),\n            targetPos,\n            stiffness,\n            damping,\n        );\n    }\n\n    public configureMotor(\n        targetPos: number,\n        targetVel: number,\n        stiffness: number,\n        damping: number,\n    ) {\n        this.rawSet.jointConfigureMotor(\n            this.handle,\n            this.rawAxis(),\n            targetPos,\n            targetVel,\n            stiffness,\n            damping,\n        );\n    }\n}\n\nexport class FixedImpulseJoint extends ImpulseJoint {}\n\nexport class RopeImpulseJoint extends ImpulseJoint {}\n\nexport class SpringImpulseJoint extends ImpulseJoint {}\n\nexport class PrismaticImpulseJoint extends UnitImpulseJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.X;\n    }\n}\n\nexport class RevoluteImpulseJoint extends UnitImpulseJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.AngX;\n    }\n}\n\n\nexport class JointData {\n    anchor1: Vector;\n    anchor2: Vector;\n    axis: Vector;\n    frame1: Rotation;\n    frame2: Rotation;\n    jointType: JointType;\n    limitsEnabled: boolean;\n    limits: Array<number>;\n    axesMask: JointAxesMask;\n    stiffness: number;\n    damping: number;\n    length: number;\n\n    private constructor() {}\n\n    /**\n     * Creates a new joint descriptor that builds a Fixed joint.\n     *\n     * A fixed joint removes all the degrees of freedom between the affected bodies, ensuring their\n     * anchor and local frames coincide in world-space.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame1 - The reference orientation of the joint wrt. the first rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame2 - The reference orientation of the joint wrt. the second rigid-body.\n     */\n    public static fixed(\n        anchor1: Vector,\n        frame1: Rotation,\n        anchor2: Vector,\n        frame2: Rotation,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.frame1 = frame1;\n        res.frame2 = frame2;\n        res.jointType = JointType.Fixed;\n        return res;\n    }\n\n    public static spring(\n        rest_length: number,\n        stiffness: number,\n        damping: number,\n        anchor1: Vector,\n        anchor2: Vector,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.length = rest_length;\n        res.stiffness = stiffness;\n        res.damping = damping;\n        res.jointType = JointType.Spring;\n        return res;\n    }\n\n    public static rope(\n        length: number,\n        anchor1: Vector,\n        anchor2: Vector,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.length = length;\n        res.jointType = JointType.Rope;\n        return res;\n    }\n\n    // #if DIM2\n\n    /**\n     * Create a new joint descriptor that builds revolute joints.\n     *\n     * A revolute joint allows three relative rotational degrees of freedom\n     * by preventing any relative translation between the anchors of the\n     * two attached rigid-bodies.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     */\n    public static revolute(anchor1: Vector, anchor2: Vector): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.jointType = JointType.Revolute;\n        return res;\n    }\n\n    /**\n     * Creates a new joint descriptor that builds a Prismatic joint.\n     *\n     * A prismatic joint removes all the degrees of freedom between the\n     * affected bodies, except for the translation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n    public static prismatic(\n        anchor1: Vector,\n        anchor2: Vector,\n        axis: Vector,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.jointType = JointType.Prismatic;\n        return res;\n    }\n\n    // #endif\n\n\n    public intoRaw(): RawGenericJoint {\n        let rawA1 = VectorOps.intoRaw(this.anchor1);\n        let rawA2 = VectorOps.intoRaw(this.anchor2);\n        let rawAx;\n        let result;\n        let limitsEnabled = false;\n        let limitsMin = 0.0;\n        let limitsMax = 0.0;\n\n        switch (this.jointType) {\n            case JointType.Fixed:\n                let rawFra1 = RotationOps.intoRaw(this.frame1);\n                let rawFra2 = RotationOps.intoRaw(this.frame2);\n                result = RawGenericJoint.fixed(rawA1, rawFra1, rawA2, rawFra2);\n                rawFra1.free();\n                rawFra2.free();\n                break;\n            case JointType.Spring:\n                result = RawGenericJoint.spring(\n                    this.length,\n                    this.stiffness,\n                    this.damping,\n                    rawA1,\n                    rawA2,\n                );\n                break;\n            case JointType.Rope:\n                result = RawGenericJoint.rope(this.length, rawA1, rawA2);\n                break;\n            case JointType.Prismatic:\n                rawAx = VectorOps.intoRaw(this.axis);\n\n                if (!!this.limitsEnabled) {\n                    limitsEnabled = true;\n                    limitsMin = this.limits[0];\n                    limitsMax = this.limits[1];\n                }\n\n                // #if DIM2\n                result = RawGenericJoint.prismatic(\n                    rawA1,\n                    rawA2,\n                    rawAx,\n                    limitsEnabled,\n                    limitsMin,\n                    limitsMax,\n                );\n                // #endif\n\n\n                rawAx.free();\n                break;\n            // #if DIM2\n            case JointType.Revolute:\n                result = RawGenericJoint.revolute(rawA1, rawA2);\n                break;\n            // #endif\n        }\n\n        rawA1.free();\n        rawA2.free();\n\n        return result;\n    }\n}\n", "import {RawImpulseJointSet} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {RigidBodySet} from \"./rigid_body_set\";\nimport {\n    RevoluteImpulseJoint,\n    FixedImpulseJoint,\n    ImpulseJoint,\n    ImpulseJointHandle,\n    JointData,\n    JointType,\n    PrismaticImpulseJoint,\n} from \"./impulse_joint\";\nimport {IslandManager} from \"./island_manager\";\nimport {RigidBodyHandle} from \"./rigid_body\";\nimport {Collider, ColliderHandle} from \"../geometry\";\n\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class ImpulseJointSet {\n    raw: RawImpulseJointSet;\n    private map: Coarena<ImpulseJoint>;\n\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawImpulseJointSet) {\n        this.raw = raw || new RawImpulseJointSet();\n        this.map = new Coarena<ImpulseJoint>();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle: ImpulseJointHandle) => {\n                this.map.set(handle, ImpulseJoint.newTyped(raw, null, handle));\n            });\n        }\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodies: RigidBodySet) {\n        this.map.forEach((joint) => joint.finalizeDeserialization(bodies));\n    }\n\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param bodies - The set of rigid-bodies containing the bodies the joint is attached to.\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createJoint(\n        bodies: RigidBodySet,\n        desc: JointData,\n        parent1: RigidBodyHandle,\n        parent2: RigidBodyHandle,\n        wakeUp: boolean,\n    ): ImpulseJoint {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(\n            rawParams,\n            parent1,\n            parent2,\n            wakeUp,\n        );\n        rawParams.free();\n        let joint = ImpulseJoint.newTyped(this.raw, bodies, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wakeUp - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    public remove(handle: ImpulseJointHandle, wakeUp: boolean) {\n        this.raw.remove(handle, wakeUp);\n        this.unmap(handle);\n    }\n\n    /**\n     * Calls the given closure with the integer handle of each impulse joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each impulse joint attached to the rigid-body.\n     */\n    public forEachJointHandleAttachedToRigidBody(\n        handle: RigidBodyHandle,\n        f: (handle: ImpulseJointHandle) => void,\n    ) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    public unmap(handle: ImpulseJointHandle) {\n        this.map.delete(handle);\n    }\n\n    /**\n     * The number of joints on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    public contains(handle: ImpulseJointHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    public get(handle: ImpulseJointHandle): ImpulseJoint | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (joint: ImpulseJoint) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    public getAll(): ImpulseJoint[] {\n        return this.map.getAll();\n    }\n}\n", "import {\n    RawImpulseJointSet,\n    RawJointAxis,\n    RawJointType,\n    RawMultibodyJointSet,\n} from \"../raw\";\nimport {\n    FixedImpulseJoint,\n    ImpulseJointHandle,\n    JointType,\n    MotorModel,\n    PrismaticImpulseJoint,\n    RevoluteImpulseJoint,\n} from \"./impulse_joint\";\n\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type MultibodyJointHandle = number;\n\nexport class MultibodyJoint {\n    protected rawSet: RawMultibodyJointSet; // The MultibodyJoint won't need to free this.\n    handle: MultibodyJointHandle;\n\n    constructor(rawSet: RawMultibodyJointSet, handle: MultibodyJointHandle) {\n        this.rawSet = rawSet;\n        this.handle = handle;\n    }\n\n    public static newTyped(\n        rawSet: RawMultibodyJointSet,\n        handle: MultibodyJointHandle,\n    ): MultibodyJoint {\n        switch (rawSet.jointType(handle)) {\n            case RawJointType.Revolute:\n                return new RevoluteMultibodyJoint(rawSet, handle);\n            case RawJointType.Prismatic:\n                return new PrismaticMultibodyJoint(rawSet, handle);\n            case RawJointType.Fixed:\n                return new FixedMultibodyJoint(rawSet, handle);\n            default:\n                return new MultibodyJoint(rawSet, handle);\n        }\n    }\n\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    public isValid(): boolean {\n        return this.rawSet.contains(this.handle);\n    }\n\n    // /**\n    //  * The unique integer identifier of the first rigid-body this joint it attached to.\n    //  */\n    // public bodyHandle1(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle1(this.handle);\n    // }\n    //\n    // /**\n    //  * The unique integer identifier of the second rigid-body this joint is attached to.\n    //  */\n    // public bodyHandle2(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle2(this.handle);\n    // }\n    //\n    // /**\n    //  * The type of this joint given as a string.\n    //  */\n    // public type(): JointType {\n    //     return this.rawSet.jointType(this.handle);\n    // }\n    //\n    //\n    //\n    // /**\n    //  * The position of the first anchor of this joint.\n    //  *\n    //  * The first anchor gives the position of the points application point on the\n    //  * local frame of the first rigid-body it is attached to.\n    //  */\n    // public anchor1(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    // }\n    //\n    // /**\n    //  * The position of the second anchor of this joint.\n    //  *\n    //  * The second anchor gives the position of the points application point on the\n    //  * local frame of the second rigid-body it is attached to.\n    //  */\n    // public anchor2(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    // }\n\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public setContactsEnabled(enabled: boolean) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public contactsEnabled(): boolean {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\n\nexport class UnitMultibodyJoint extends MultibodyJoint {\n    /**\n     * The axis left free by this joint.\n     */\n    protected rawAxis?(): RawJointAxis;\n\n    // /**\n    //  * Are the limits enabled for this joint?\n    //  */\n    // public limitsEnabled(): boolean {\n    //     return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());\n    // }\n    //\n    // /**\n    //  * The min limit of this joint.\n    //  */\n    // public limitsMin(): number {\n    //     return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());\n    // }\n    //\n    // /**\n    //  * The max limit of this joint.\n    //  */\n    // public limitsMax(): number {\n    //     return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());\n    // }\n    //\n    // public configureMotorModel(model: MotorModel) {\n    //     this.rawSet.jointConfigureMotorModel(this.handle, this.rawAxis(), model);\n    // }\n    //\n    // public configureMotorVelocity(targetVel: number, factor: number) {\n    //     this.rawSet.jointConfigureMotorVelocity(this.handle, this.rawAxis(), targetVel, factor);\n    // }\n    //\n    // public configureMotorPosition(targetPos: number, stiffness: number, damping: number) {\n    //     this.rawSet.jointConfigureMotorPosition(this.handle, this.rawAxis(), targetPos, stiffness, damping);\n    // }\n    //\n    // public configureMotor(targetPos: number, targetVel: number, stiffness: number, damping: number) {\n    //     this.rawSet.jointConfigureMotor(this.handle, this.rawAxis(), targetPos, targetVel, stiffness, damping);\n    // }\n}\n\nexport class FixedMultibodyJoint extends MultibodyJoint {}\n\nexport class PrismaticMultibodyJoint extends UnitMultibodyJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.X;\n    }\n}\n\nexport class RevoluteMultibodyJoint extends UnitMultibodyJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.AngX;\n    }\n}\n\n", "import {RawMultibodyJointSet} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {RigidBodySet} from \"./rigid_body_set\";\nimport {\n    MultibodyJoint,\n    MultibodyJointHandle,\n    RevoluteMultibodyJoint,\n    FixedMultibodyJoint,\n    PrismaticMultibodyJoint,\n} from \"./multibody_joint\";\nimport {ImpulseJointHandle, JointData, JointType} from \"./impulse_joint\";\nimport {IslandManager} from \"./island_manager\";\nimport {ColliderHandle} from \"../geometry\";\nimport {RigidBodyHandle} from \"./rigid_body\";\n\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class MultibodyJointSet {\n    raw: RawMultibodyJointSet;\n    private map: Coarena<MultibodyJoint>;\n\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawMultibodyJointSet) {\n        this.raw = raw || new RawMultibodyJointSet();\n        this.map = new Coarena<MultibodyJoint>();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle: MultibodyJointHandle) => {\n                this.map.set(handle, MultibodyJoint.newTyped(this.raw, handle));\n            });\n        }\n    }\n\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createJoint(\n        desc: JointData,\n        parent1: RigidBodyHandle,\n        parent2: RigidBodyHandle,\n        wakeUp: boolean,\n    ): MultibodyJoint {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(\n            rawParams,\n            parent1,\n            parent2,\n            wakeUp,\n        );\n        rawParams.free();\n        let joint = MultibodyJoint.newTyped(this.raw, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wake_up - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    public remove(handle: MultibodyJointHandle, wake_up: boolean) {\n        this.raw.remove(handle, wake_up);\n        this.map.delete(handle);\n    }\n\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    public unmap(handle: MultibodyJointHandle) {\n        this.map.delete(handle);\n    }\n\n    /**\n     * The number of joints on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    public contains(handle: MultibodyJointHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    public get(handle: MultibodyJointHandle): MultibodyJoint | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (joint: MultibodyJoint) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Calls the given closure with the integer handle of each multibody joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each multibody joint attached to the rigid-body.\n     */\n    public forEachJointHandleAttachedToRigidBody(\n        handle: RigidBodyHandle,\n        f: (handle: MultibodyJointHandle) => void,\n    ) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    public getAll(): MultibodyJoint[] {\n        return this.map.getAll();\n    }\n}\n", "/**\n * A rule applied to combine coefficients.\n *\n * Use this when configuring the `ColliderDesc` to specify\n * how friction and restitution coefficient should be combined\n * in a contact.\n */\nexport enum CoefficientCombineRule {\n    Average = 0,\n    Min = 1,\n    Multiply = 2,\n    Max = 3,\n}\n", "import {RawCCDSolver} from \"../raw\";\n\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class CCDSolver {\n    raw: RawCCDSolver;\n\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawCCDSolver) {\n        this.raw = raw || new RawCCDSolver();\n    }\n}\n", "import {RawIslandManager} from \"../raw\";\nimport {RigidBodyHandle} from \"./rigid_body\";\n\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class IslandManager {\n    raw: RawIslandManager;\n\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawIslandManager) {\n        this.raw = raw || new RawIslandManager();\n    }\n\n    /**\n     * Applies the given closure to the handle of each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEachActiveRigidBodyHandle(f: (handle: RigidBodyHandle) => void) {\n        this.raw.forEachActiveRigidBodyHandle(f);\n    }\n}\n", "import {RawBroadPhase} from \"../raw\";\n\n/**\n * The broad-phase used for coarse collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `broadPhase.free()`\n * once you are done using it.\n */\nexport class BroadPhase {\n    raw: RawBroadPhase;\n\n    /**\n     * Release the WASM memory occupied by this broad-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawBroadPhase) {\n        this.raw = raw || new RawBroadPhase();\n    }\n}\n", "import {RawNarrowPhase, RawContactManifold} from \"../raw\";\nimport {ColliderHandle} from \"./collider\";\nimport {Vector, VectorOps} from \"../math\";\n\n/**\n * The narrow-phase used for precise collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `narrowPhase.free()`\n * once you are done using it.\n */\nexport class NarrowPhase {\n    raw: RawNarrowPhase;\n    tempManifold: TempContactManifold;\n\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawNarrowPhase) {\n        this.raw = raw || new RawNarrowPhase();\n        this.tempManifold = new TempContactManifold(null);\n    }\n\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    public contactPairsWith(\n        collider1: ColliderHandle,\n        f: (collider2: ColliderHandle) => void,\n    ) {\n        this.raw.contact_pairs_with(collider1, f);\n    }\n\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    public intersectionPairsWith(\n        collider1: ColliderHandle,\n        f: (collider2: ColliderHandle) => void,\n    ) {\n        this.raw.intersection_pairs_with(collider1, f);\n    }\n\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    public contactPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n        f: (manifold: TempContactManifold, flipped: boolean) => void,\n    ) {\n        const rawPair = this.raw.contact_pair(collider1, collider2);\n\n        if (!!rawPair) {\n            const flipped = rawPair.collider1() != collider1;\n\n            let i;\n            for (i = 0; i < rawPair.numContactManifolds(); ++i) {\n                this.tempManifold.raw = rawPair.contactManifold(i);\n                if (!!this.tempManifold.raw) {\n                    f(this.tempManifold, flipped);\n                }\n\n                // SAFETY: The RawContactManifold stores a raw pointer that will be invalidated\n                //         at the next timestep. So we must be sure to free the pair here\n                //         to avoid unsoundness in the Rust code.\n                this.tempManifold.free();\n            }\n            rawPair.free();\n        }\n    }\n\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1  The first collider involved in the intersection.\n     * @param collider2  The second collider involved in the intersection.\n     */\n    public intersectionPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n    ): boolean {\n        return this.raw.intersection_pair(collider1, collider2);\n    }\n}\n\nexport class TempContactManifold {\n    raw: RawContactManifold;\n\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw: RawContactManifold) {\n        this.raw = raw;\n    }\n\n    public normal(): Vector {\n        return VectorOps.fromRaw(this.raw.normal());\n    }\n\n    public localNormal1(): Vector {\n        return VectorOps.fromRaw(this.raw.local_n1());\n    }\n\n    public localNormal2(): Vector {\n        return VectorOps.fromRaw(this.raw.local_n2());\n    }\n\n    public subshape1(): number {\n        return this.raw.subshape1();\n    }\n\n    public subshape2(): number {\n        return this.raw.subshape2();\n    }\n\n    public numContacts(): number {\n        return this.raw.num_contacts();\n    }\n\n    public localContactPoint1(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.contact_local_p1(i));\n    }\n\n    public localContactPoint2(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.contact_local_p2(i));\n    }\n\n    public contactDist(i: number): number {\n        return this.raw.contact_dist(i);\n    }\n\n    public contactFid1(i: number): number {\n        return this.raw.contact_fid1(i);\n    }\n\n    public contactFid2(i: number): number {\n        return this.raw.contact_fid2(i);\n    }\n\n    public contactImpulse(i: number): number {\n        return this.raw.contact_impulse(i);\n    }\n\n    // #if DIM2\n    public contactTangentImpulse(i: number): number {\n        return this.raw.contact_tangent_impulse(i);\n    }\n    // #endif\n\n\n    public numSolverContacts(): number {\n        return this.raw.num_solver_contacts();\n    }\n\n    public solverContactPoint(i: number): Vector {\n        return VectorOps.fromRaw(this.raw.solver_contact_point(i));\n    }\n\n    public solverContactDist(i: number): number {\n        return this.raw.solver_contact_dist(i);\n    }\n\n    public solverContactFriction(i: number): number {\n        return this.raw.solver_contact_friction(i);\n    }\n\n    public solverContactRestitution(i: number): number {\n        return this.raw.solver_contact_restitution(i);\n    }\n\n    public solverContactTangentVelocity(i: number): Vector {\n        return VectorOps.fromRaw(this.raw.solver_contact_tangent_velocity(i));\n    }\n}\n", "import {Vector, VectorOps} from \"../math\";\nimport {RawShapeContact} from \"../raw\";\n\n/**\n * The contact info between two shapes.\n */\nexport class ShapeContact {\n    /**\n     * Distance between the two contact points.\n     * If this is negative, this contact represents a penetration.\n     */\n    distance: number;\n\n    /**\n     * Position of the contact on the first shape.\n     */\n    point1: Vector;\n\n    /**\n     * Position of the contact on the second shape.\n     */\n    point2: Vector;\n\n    /**\n     * Contact normal, pointing towards the exterior of the first shape.\n     */\n    normal1: Vector;\n\n    /**\n     * Contact normal, pointing towards the exterior of the second shape.\n     * If these contact data are expressed in world-space, this normal is equal to -normal1.\n     */\n    normal2: Vector;\n\n    constructor(\n        dist: number,\n        point1: Vector,\n        point2: Vector,\n        normal1: Vector,\n        normal2: Vector,\n    ) {\n        this.distance = dist;\n        this.point1 = point1;\n        this.point2 = point2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n\n    public static fromRaw(raw: RawShapeContact): ShapeContact {\n        if (!raw) return null;\n\n        const result = new ShapeContact(\n            raw.distance(),\n            VectorOps.fromRaw(raw.point1()),\n            VectorOps.fromRaw(raw.point2()),\n            VectorOps.fromRaw(raw.normal1()),\n            VectorOps.fromRaw(raw.normal2()),\n        );\n        raw.free();\n        return result;\n    }\n}\n", "// #if DIM2\nexport enum FeatureType {\n    Vertex,\n    Face,\n    Unknown,\n}\n// #endif\n\n", "import {Collider, ColliderHandle} from \"./collider\";\nimport {Vector, VectorOps} from \"../math\";\nimport {\n    RawFeatureType,\n    RawPointColliderProjection,\n    RawPointProjection,\n} from \"../raw\";\nimport {FeatureType} from \"./feature\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * The projection of a point on a collider.\n */\nexport class PointProjection {\n    /**\n     * The projection of the point on the collider.\n     */\n    point: Vector;\n    /**\n     * Is the point inside of the collider?\n     */\n    isInside: boolean;\n\n    constructor(point: Vector, isInside: boolean) {\n        this.point = point;\n        this.isInside = isInside;\n    }\n\n    public static fromRaw(raw: RawPointProjection): PointProjection {\n        if (!raw) return null;\n\n        const result = new PointProjection(\n            VectorOps.fromRaw(raw.point()),\n            raw.isInside(),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The projection of a point on a collider (includes the collider handle).\n */\nexport class PointColliderProjection {\n    /**\n     * The collider hit by the ray.\n     */\n    collider: Collider;\n    /**\n     * The projection of the point on the collider.\n     */\n    point: Vector;\n    /**\n     * Is the point inside of the collider?\n     */\n    isInside: boolean;\n\n    /**\n     * The type of the geometric feature the point was projected on.\n     */\n    featureType = FeatureType.Unknown;\n\n    /**\n     * The id of the geometric feature the point was projected on.\n     */\n    featureId: number | undefined = undefined;\n\n    constructor(\n        collider: Collider,\n        point: Vector,\n        isInside: boolean,\n        featureType?: FeatureType,\n        featureId?: number,\n    ) {\n        this.collider = collider;\n        this.point = point;\n        this.isInside = isInside;\n        if (featureId !== undefined) this.featureId = featureId;\n        if (featureType !== undefined) this.featureType = featureType;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawPointColliderProjection,\n    ): PointColliderProjection {\n        if (!raw) return null;\n\n        const result = new PointColliderProjection(\n            colliderSet.get(raw.colliderHandle()),\n            VectorOps.fromRaw(raw.point()),\n            raw.isInside(),\n            raw.featureType() as number as FeatureType,\n            raw.featureId(),\n        );\n        raw.free();\n        return result;\n    }\n}\n", "import {Vector, VectorOps} from \"../math\";\nimport {\n    RawFeatureType,\n    RawRayColliderIntersection,\n    RawRayColliderHit,\n    RawRayIntersection,\n} from \"../raw\";\nimport {Collider} from \"./collider\";\nimport {FeatureType} from \"./feature\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * A ray. This is a directed half-line.\n */\nexport class Ray {\n    /**\n     * The starting point of the ray.\n     */\n    public origin: Vector;\n    /**\n     * The direction of propagation of the ray.\n     */\n    public dir: Vector;\n\n    /**\n     * Builds a ray from its origin and direction.\n     *\n     * @param origin - The ray's starting point.\n     * @param dir - The ray's direction of propagation.\n     */\n    constructor(origin: Vector, dir: Vector) {\n        this.origin = origin;\n        this.dir = dir;\n    }\n\n    public pointAt(t: number): Vector {\n        return {\n            x: this.origin.x + this.dir.x * t,\n            y: this.origin.y + this.dir.y * t,\n        };\n    }\n}\n\n/**\n * The intersection between a ray and a collider.\n */\nexport class RayIntersection {\n    /**\n     * The time-of-impact of the ray with the collider.\n     *\n     * The hit point is obtained from the ray's origin and direction: `origin + dir * timeOfImpact`.\n     */\n    timeOfImpact: number;\n    /**\n     * The normal of the collider at the hit point.\n     */\n    normal: Vector;\n\n    /**\n     * The type of the geometric feature the point was projected on.\n     */\n    featureType = FeatureType.Unknown;\n\n    /**\n     * The id of the geometric feature the point was projected on.\n     */\n    featureId: number | undefined = undefined;\n\n    constructor(\n        timeOfImpact: number,\n        normal: Vector,\n        featureType?: FeatureType,\n        featureId?: number,\n    ) {\n        this.timeOfImpact = timeOfImpact;\n        this.normal = normal;\n        if (featureId !== undefined) this.featureId = featureId;\n        if (featureType !== undefined) this.featureType = featureType;\n    }\n\n    public static fromRaw(raw: RawRayIntersection): RayIntersection {\n        if (!raw) return null;\n\n        const result = new RayIntersection(\n            raw.time_of_impact(),\n            VectorOps.fromRaw(raw.normal()),\n            raw.featureType() as number as FeatureType,\n            raw.featureId(),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The intersection between a ray and a collider (includes the collider handle).\n */\nexport class RayColliderIntersection {\n    /**\n     * The collider hit by the ray.\n     */\n    collider: Collider;\n    /**\n     * The time-of-impact of the ray with the collider.\n     *\n     * The hit point is obtained from the ray's origin and direction: `origin + dir * timeOfImpact`.\n     */\n    timeOfImpact: number;\n    /**\n     * The normal of the collider at the hit point.\n     */\n    normal: Vector;\n\n    /**\n     * The type of the geometric feature the point was projected on.\n     */\n    featureType = FeatureType.Unknown;\n\n    /**\n     * The id of the geometric feature the point was projected on.\n     */\n    featureId: number | undefined = undefined;\n\n    constructor(\n        collider: Collider,\n        timeOfImpact: number,\n        normal: Vector,\n        featureType?: FeatureType,\n        featureId?: number,\n    ) {\n        this.collider = collider;\n        this.timeOfImpact = timeOfImpact;\n        this.normal = normal;\n        if (featureId !== undefined) this.featureId = featureId;\n        if (featureType !== undefined) this.featureType = featureType;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawRayColliderIntersection,\n    ): RayColliderIntersection {\n        if (!raw) return null;\n\n        const result = new RayColliderIntersection(\n            colliderSet.get(raw.colliderHandle()),\n            raw.time_of_impact(),\n            VectorOps.fromRaw(raw.normal()),\n            raw.featureType() as number as FeatureType,\n            raw.featureId(),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The time of impact between a ray and a collider.\n */\nexport class RayColliderHit {\n    /**\n     * The handle of the collider hit by the ray.\n     */\n    collider: Collider;\n    /**\n     * The time-of-impact of the ray with the collider.\n     *\n     * The hit point is obtained from the ray's origin and direction: `origin + dir * timeOfImpact`.\n     */\n    timeOfImpact: number;\n\n    constructor(collider: Collider, timeOfImpact: number) {\n        this.collider = collider;\n        this.timeOfImpact = timeOfImpact;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawRayColliderHit,\n    ): RayColliderHit {\n        if (!raw) return null;\n\n        const result = new RayColliderHit(\n            colliderSet.get(raw.colliderHandle()),\n            raw.timeOfImpact(),\n        );\n        raw.free();\n        return result;\n    }\n}\n", "import {Collider} from \"./collider\";\nimport {Vector, VectorOps} from \"../math\";\nimport {RawShapeCastHit, RawColliderShapeCastHit} from \"../raw\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * The intersection between a ray and a collider.\n */\nexport class ShapeCastHit {\n    /**\n     * The time of impact of the two shapes.\n     */\n    time_of_impact: number;\n    /**\n     * The local-space contact point on the first shape, at\n     * the time of impact.\n     */\n    witness1: Vector;\n    /**\n     * The local-space contact point on the second shape, at\n     * the time of impact.\n     */\n    witness2: Vector;\n    /**\n     * The local-space normal on the first shape, at\n     * the time of impact.\n     */\n    normal1: Vector;\n    /**\n     * The local-space normal on the second shape, at\n     * the time of impact.\n     */\n    normal2: Vector;\n\n    constructor(\n        time_of_impact: number,\n        witness1: Vector,\n        witness2: Vector,\n        normal1: Vector,\n        normal2: Vector,\n    ) {\n        this.time_of_impact = time_of_impact;\n        this.witness1 = witness1;\n        this.witness2 = witness2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawShapeCastHit,\n    ): ShapeCastHit {\n        if (!raw) return null;\n\n        const result = new ShapeCastHit(\n            raw.time_of_impact(),\n            VectorOps.fromRaw(raw.witness1()),\n            VectorOps.fromRaw(raw.witness2()),\n            VectorOps.fromRaw(raw.normal1()),\n            VectorOps.fromRaw(raw.normal2()),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The intersection between a ray and a collider.\n */\nexport class ColliderShapeCastHit extends ShapeCastHit {\n    /**\n     * The handle of the collider hit by the ray.\n     */\n    collider: Collider;\n\n    constructor(\n        collider: Collider,\n        time_of_impact: number,\n        witness1: Vector,\n        witness2: Vector,\n        normal1: Vector,\n        normal2: Vector,\n    ) {\n        super(time_of_impact, witness1, witness2, normal1, normal2);\n        this.collider = collider;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawColliderShapeCastHit,\n    ): ColliderShapeCastHit {\n        if (!raw) return null;\n\n        const result = new ColliderShapeCastHit(\n            colliderSet.get(raw.colliderHandle()),\n            raw.time_of_impact(),\n            VectorOps.fromRaw(raw.witness1()),\n            VectorOps.fromRaw(raw.witness2()),\n            VectorOps.fromRaw(raw.normal1()),\n            VectorOps.fromRaw(raw.normal2()),\n        );\n        raw.free();\n        return result;\n    }\n}\n", "import {Vector, VectorOps, Rotation, RotationOps} from \"../math\";\nimport {RawColliderSet, RawShape, RawShapeType} from \"../raw\";\nimport {ShapeContact} from \"./contact\";\nimport {PointProjection} from \"./point\";\nimport {Ray, RayIntersection} from \"./ray\";\nimport {ShapeCastHit} from \"./toi\";\nimport {ColliderHandle} from \"./collider\";\n\nexport abstract class Shape {\n    public abstract intoRaw(): RawShape;\n\n    /**\n     * The concrete type of this shape.\n     */\n    public abstract get type(): ShapeType;\n\n    /**\n     * instant mode without cache\n     */\n    public static fromRaw(\n        rawSet: RawColliderSet,\n        handle: ColliderHandle,\n    ): Shape {\n        const rawType = rawSet.coShapeType(handle);\n\n        let extents: Vector;\n        let borderRadius: number;\n        let vs: Float32Array;\n        let indices: Uint32Array;\n        let halfHeight: number;\n        let radius: number;\n        let normal: Vector;\n\n        switch (rawType) {\n            case RawShapeType.Ball:\n                return new Ball(rawSet.coRadius(handle));\n            case RawShapeType.Cuboid:\n                extents = rawSet.coHalfExtents(handle);\n                // #if DIM2\n                return new Cuboid(extents.x, extents.y);\n                // #endif\n\n\n            case RawShapeType.RoundCuboid:\n                extents = rawSet.coHalfExtents(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n\n                // #if DIM2\n                return new RoundCuboid(extents.x, extents.y, borderRadius);\n                // #endif\n\n\n            case RawShapeType.Capsule:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Capsule(halfHeight, radius);\n            case RawShapeType.Segment:\n                vs = rawSet.coVertices(handle);\n\n                // #if DIM2\n                return new Segment(\n                    VectorOps.new(vs[0], vs[1]),\n                    VectorOps.new(vs[2], vs[3]),\n                );\n                // #endif\n\n\n            case RawShapeType.Polyline:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new Polyline(vs, indices);\n            case RawShapeType.Triangle:\n                vs = rawSet.coVertices(handle);\n\n                // #if DIM2\n                return new Triangle(\n                    VectorOps.new(vs[0], vs[1]),\n                    VectorOps.new(vs[2], vs[3]),\n                    VectorOps.new(vs[4], vs[5]),\n                );\n                // #endif\n\n\n            case RawShapeType.RoundTriangle:\n                vs = rawSet.coVertices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n\n                // #if DIM2\n                return new RoundTriangle(\n                    VectorOps.new(vs[0], vs[1]),\n                    VectorOps.new(vs[2], vs[3]),\n                    VectorOps.new(vs[4], vs[5]),\n                    borderRadius,\n                );\n                // #endif\n\n\n            case RawShapeType.HalfSpace:\n                normal = VectorOps.fromRaw(rawSet.coHalfspaceNormal(handle));\n                return new HalfSpace(normal);\n\n            case RawShapeType.TriMesh:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                const tri_flags = rawSet.coTriMeshFlags(handle);\n                return new TriMesh(vs, indices, tri_flags);\n\n            case RawShapeType.HeightField:\n                const scale = rawSet.coHeightfieldScale(handle);\n                const heights = rawSet.coHeightfieldHeights(handle);\n\n                // #if DIM2\n                return new Heightfield(heights, scale);\n                // #endif\n\n\n            // #if DIM2\n            case RawShapeType.ConvexPolygon:\n                vs = rawSet.coVertices(handle);\n                return new ConvexPolygon(vs, false);\n            case RawShapeType.RoundConvexPolygon:\n                vs = rawSet.coVertices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundConvexPolygon(vs, borderRadius, false);\n            // #endif\n\n\n            default:\n                throw new Error(\"unknown shape type: \" + rawType);\n        }\n    }\n\n    /**\n     * Computes the time of impact between two moving shapes.\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shapeVel1 - The velocity of this shape.\n     * @param shape2 - The second moving shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param shapeVel2 - The velocity of the second shape.\n     * @param targetDistance  If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time when the impact can happen.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     * @returns If the two moving shapes collider at some point along their trajectories, this returns the\n     *  time at which the two shape collider as well as the contact information during the impact. Returns\n     *  `null`if the two shapes never collide along their paths.\n     */\n    public castShape(\n        shapePos1: Vector,\n        shapeRot1: Rotation,\n        shapeVel1: Vector,\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n        shapeVel2: Vector,\n        targetDistance: number,\n        maxToi: number,\n        stopAtPenetration: boolean,\n    ): ShapeCastHit | null {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawVel1 = VectorOps.intoRaw(shapeVel1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawVel2 = VectorOps.intoRaw(shapeVel2);\n\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeCastHit.fromRaw(\n            null,\n            rawShape1.castShape(\n                rawPos1,\n                rawRot1,\n                rawVel1,\n                rawShape2,\n                rawPos2,\n                rawRot2,\n                rawVel2,\n                targetDistance,\n                maxToi,\n                stopAtPenetration,\n            ),\n        );\n\n        rawPos1.free();\n        rawRot1.free();\n        rawVel1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawVel2.free();\n\n        rawShape1.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Tests if this shape intersects another shape.\n     *\n     * @param shapePos1 - The position of this shape.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2  - The second shape to test.\n     * @param shapePos2 - The position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @returns `true` if the two shapes intersect, `false` if they dont.\n     */\n    public intersectsShape(\n        shapePos1: Vector,\n        shapeRot1: Rotation,\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n    ): boolean {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n\n        let result = rawShape1.intersectsShape(\n            rawPos1,\n            rawRot1,\n            rawShape2,\n            rawPos2,\n            rawRot2,\n        );\n\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n\n        rawShape1.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Computes one pair of contact points between two shapes.\n     *\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2 - The second shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(\n        shapePos1: Vector,\n        shapeRot1: Rotation,\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n        prediction: number,\n    ): ShapeContact | null {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeContact.fromRaw(\n            rawShape1.contactShape(\n                rawPos1,\n                rawRot1,\n                rawShape2,\n                rawPos2,\n                rawRot2,\n                prediction,\n            ),\n        );\n\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n\n        rawShape1.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    containsPoint(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        point: Vector,\n    ): boolean {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n\n        let result = rawShape.containsPoint(rawPos, rawRot, rawPoint);\n\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    projectPoint(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        point: Vector,\n        solid: boolean,\n    ): PointProjection {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n\n        let result = PointProjection.fromRaw(\n            rawShape.projectPoint(rawPos, rawRot, rawPoint, solid),\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    intersectsRay(\n        ray: Ray,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        maxToi: number,\n    ): boolean {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n\n        let result = rawShape.intersectsRay(\n            rawPos,\n            rawRot,\n            rawRayOrig,\n            rawRayDir,\n            maxToi,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    castRay(\n        ray: Ray,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        maxToi: number,\n        solid: boolean,\n    ): number {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n\n        let result = rawShape.castRay(\n            rawPos,\n            rawRot,\n            rawRayOrig,\n            rawRayDir,\n            maxToi,\n            solid,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    castRayAndGetNormal(\n        ray: Ray,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        maxToi: number,\n        solid: boolean,\n    ): RayIntersection {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n\n        let result = RayIntersection.fromRaw(\n            rawShape.castRayAndGetNormal(\n                rawPos,\n                rawRot,\n                rawRayOrig,\n                rawRayDir,\n                maxToi,\n                solid,\n            ),\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n\n        return result;\n    }\n}\n\n// #if DIM2\n/**\n * An enumeration representing the type of a shape.\n */\nexport enum ShapeType {\n    Ball = 0,\n    Cuboid = 1,\n    Capsule = 2,\n    Segment = 3,\n    Polyline = 4,\n    Triangle = 5,\n    TriMesh = 6,\n    HeightField = 7,\n    // Compound = 8,\n    ConvexPolygon = 9,\n    RoundCuboid = 10,\n    RoundTriangle = 11,\n    RoundConvexPolygon = 12,\n    HalfSpace = 13,\n}\n\n// #endif\n\n\n// NOTE: this **must** match the TriMeshFlags on the rust side.\n/**\n * Flags controlling the behavior of the triangle mesh creation and of some\n * operations involving triangle meshes.\n */\nexport enum TriMeshFlags {\n    // NOTE: these two flags are not really useful in JS.\n    //\n    // /**\n    //  * If set, the half-edge topology of the trimesh will be computed if possible.\n    //  */\n    // HALF_EDGE_TOPOLOGY = 0b0000_0001,\n    // /** If set, the half-edge topology and connected components of the trimesh will be computed if possible.\n    //  *\n    //  * Because of the way it is currently implemented, connected components can only be computed on\n    //  * a mesh where the half-edge topology computation succeeds. It will no longer be the case in the\n    //  * future once we decouple the computations.\n    //  */\n    // CONNECTED_COMPONENTS = 0b0000_0010,\n    /**\n     * If set, any triangle that results in a failing half-hedge topology computation will be deleted.\n     */\n    DELETE_BAD_TOPOLOGY_TRIANGLES = 0b0000_0100,\n    /**\n     * If set, the trimesh will be assumed to be oriented (with outward normals).\n     *\n     * The pseudo-normals of its vertices and edges will be computed.\n     */\n    ORIENTED = 0b0000_1000,\n    /**\n     * If set, the duplicate vertices of the trimesh will be merged.\n     *\n     * Two vertices with the exact same coordinates will share the same entry on the\n     * vertex buffer and the index buffer is adjusted accordingly.\n     */\n    MERGE_DUPLICATE_VERTICES = 0b0001_0000,\n    /**\n     * If set, the triangles sharing two vertices with identical index values will be removed.\n     *\n     * Because of the way it is currently implemented, this methods implies that duplicate\n     * vertices will be merged. It will no longer be the case in the future once we decouple\n     * the computations.\n     */\n    DELETE_DEGENERATE_TRIANGLES = 0b0010_0000,\n    /**\n     * If set, two triangles sharing three vertices with identical index values (in any order)\n     * will be removed.\n     *\n     * Because of the way it is currently implemented, this methods implies that duplicate\n     * vertices will be merged. It will no longer be the case in the future once we decouple\n     * the computations.\n     */\n    DELETE_DUPLICATE_TRIANGLES = 0b0100_0000,\n    /**\n     * If set, a special treatment will be applied to contact manifold calculation to eliminate\n     * or fix contacts normals that could lead to incorrect bumps in physics simulation\n     * (especially on flat surfaces).\n     *\n     * This is achieved by taking into account adjacent triangle normals when computing contact\n     * points for a given triangle.\n     *\n     * /!\\ NOT SUPPORTED IN THE 2D VERSION OF RAPIER.\n     */\n    FIX_INTERNAL_EDGES = 0b1000_0000 |\n        TriMeshFlags.ORIENTED |\n        TriMeshFlags.MERGE_DUPLICATE_VERTICES,\n}\n\n/**\n * A shape that is a sphere in 3D and a circle in 2D.\n */\nexport class Ball extends Shape {\n    readonly type = ShapeType.Ball;\n\n    /**\n     * The balls radius.\n     */\n    radius: number;\n\n    /**\n     * Creates a new ball with the given radius.\n     * @param radius - The balls radius.\n     */\n    constructor(radius: number) {\n        super();\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.ball(this.radius);\n    }\n}\n\nexport class HalfSpace extends Shape {\n    readonly type = ShapeType.HalfSpace;\n\n    /**\n     * The outward normal of the half-space.\n     */\n    normal: Vector;\n\n    /**\n     * Creates a new halfspace delimited by an infinite plane.\n     *\n     * @param normal - The outward normal of the plane.\n     */\n    constructor(normal: Vector) {\n        super();\n        this.normal = normal;\n    }\n\n    public intoRaw(): RawShape {\n        let n = VectorOps.intoRaw(this.normal);\n        let result = RawShape.halfspace(n);\n        n.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a box in 3D and a rectangle in 2D.\n */\nexport class Cuboid extends Shape {\n    readonly type = ShapeType.Cuboid;\n\n    /**\n     * The half extent of the cuboid along each coordinate axis.\n     */\n    halfExtents: Vector;\n\n    // #if DIM2\n    /**\n     * Creates a new 2D rectangle.\n     * @param hx - The half width of the rectangle.\n     * @param hy - The helf height of the rectangle.\n     */\n    constructor(hx: number, hy: number) {\n        super();\n        this.halfExtents = VectorOps.new(hx, hy);\n    }\n\n    // #endif\n\n\n    public intoRaw(): RawShape {\n        // #if DIM2\n        return RawShape.cuboid(this.halfExtents.x, this.halfExtents.y);\n        // #endif\n\n    }\n}\n\n/**\n * A shape that is a box in 3D and a rectangle in 2D, with round corners.\n */\nexport class RoundCuboid extends Shape {\n    readonly type = ShapeType.RoundCuboid;\n\n    /**\n     * The half extent of the cuboid along each coordinate axis.\n     */\n    halfExtents: Vector;\n\n    /**\n     * The radius of the cuboid's round border.\n     */\n    borderRadius: number;\n\n    // #if DIM2\n    /**\n     * Creates a new 2D rectangle.\n     * @param hx - The half width of the rectangle.\n     * @param hy - The helf height of the rectangle.\n     * @param borderRadius - The radius of the borders of this cuboid. This will\n     *   effectively increase the half-extents of the cuboid by this radius.\n     */\n    constructor(hx: number, hy: number, borderRadius: number) {\n        super();\n        this.halfExtents = VectorOps.new(hx, hy);\n        this.borderRadius = borderRadius;\n    }\n\n    // #endif\n\n\n    public intoRaw(): RawShape {\n        // #if DIM2\n        return RawShape.roundCuboid(\n            this.halfExtents.x,\n            this.halfExtents.y,\n            this.borderRadius,\n        );\n        // #endif\n\n    }\n}\n\n/**\n * A shape that is a capsule.\n */\nexport class Capsule extends Shape {\n    readonly type = ShapeType.Capsule;\n\n    /**\n     * The radius of the capsule's basis.\n     */\n    radius: number;\n\n    /**\n     * The capsule's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * Creates a new capsule with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight: number, radius: number) {\n        super();\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.capsule(this.halfHeight, this.radius);\n    }\n}\n\n/**\n * A shape that is a segment.\n */\nexport class Segment extends Shape {\n    readonly type = ShapeType.Segment;\n\n    /**\n     * The first point of the segment.\n     */\n    a: Vector;\n\n    /**\n     * The second point of the segment.\n     */\n    b: Vector;\n\n    /**\n     * Creates a new segment shape.\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    constructor(a: Vector, b: Vector) {\n        super();\n        this.a = a;\n        this.b = b;\n    }\n\n    public intoRaw(): RawShape {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let result = RawShape.segment(ra, rb);\n        ra.free();\n        rb.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a segment.\n */\nexport class Triangle extends Shape {\n    readonly type = ShapeType.Triangle;\n\n    /**\n     * The first point of the triangle.\n     */\n    a: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    b: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    c: Vector;\n\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    constructor(a: Vector, b: Vector, c: Vector) {\n        super();\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n\n    public intoRaw(): RawShape {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.triangle(ra, rb, rc);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a triangle with round borders and a non-zero thickness.\n */\nexport class RoundTriangle extends Shape {\n    readonly type = ShapeType.RoundTriangle;\n\n    /**\n     * The first point of the triangle.\n     */\n    a: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    b: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    c: Vector;\n\n    /**\n     * The radius of the triangles's rounded edges and vertices.\n     * In 3D, this is also equal to half the thickness of the round triangle.\n     */\n    borderRadius: number;\n\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    constructor(a: Vector, b: Vector, c: Vector, borderRadius: number) {\n        super();\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.borderRadius = borderRadius;\n    }\n\n    public intoRaw(): RawShape {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.roundTriangle(ra, rb, rc, this.borderRadius);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a triangle mesh.\n */\nexport class Polyline extends Shape {\n    readonly type = ShapeType.Polyline;\n\n    /**\n     * The vertices of the polyline.\n     */\n    vertices: Float32Array;\n\n    /**\n     * The indices of the segments.\n     */\n    indices: Uint32Array;\n\n    /**\n     * Creates a new polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `null` or not provided, then\n     *    the vertices are assumed to form a line strip.\n     */\n    constructor(vertices: Float32Array, indices?: Uint32Array) {\n        super();\n        this.vertices = vertices;\n        this.indices = indices ?? new Uint32Array(0);\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.polyline(this.vertices, this.indices);\n    }\n}\n\n/**\n * A shape that is a triangle mesh.\n */\nexport class TriMesh extends Shape {\n    readonly type = ShapeType.TriMesh;\n\n    /**\n     * The vertices of the triangle mesh.\n     */\n    vertices: Float32Array;\n\n    /**\n     * The indices of the triangles.\n     */\n    indices: Uint32Array;\n\n    /**\n     * The triangle mesh flags.\n     */\n    flags: TriMeshFlags;\n\n    /**\n     * Creates a new triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    constructor(\n        vertices: Float32Array,\n        indices: Uint32Array,\n        flags?: TriMeshFlags,\n    ) {\n        super();\n        this.vertices = vertices;\n        this.indices = indices;\n        this.flags = flags;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.trimesh(this.vertices, this.indices, this.flags);\n    }\n}\n\n// #if DIM2\n/**\n * A shape that is a convex polygon.\n */\nexport class ConvexPolygon extends Shape {\n    readonly type = ShapeType.ConvexPolygon;\n\n    /**\n     * The vertices of the convex polygon.\n     */\n    vertices: Float32Array;\n\n    /**\n     * Do we want to assume the vertices already form a convex hull?\n     */\n    skipConvexHullComputation: boolean;\n\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param skipConvexHullComputation - If set to `true`, the input points will\n     *   be assumed to form a convex polyline and no convex-hull computation will\n     *   be done automatically.\n     */\n    constructor(vertices: Float32Array, skipConvexHullComputation: boolean) {\n        super();\n        this.vertices = vertices;\n        this.skipConvexHullComputation = !!skipConvexHullComputation;\n    }\n\n    public intoRaw(): RawShape {\n        if (this.skipConvexHullComputation) {\n            return RawShape.convexPolyline(this.vertices);\n        } else {\n            return RawShape.convexHull(this.vertices);\n        }\n    }\n}\n\n/**\n * A shape that is a convex polygon.\n */\nexport class RoundConvexPolygon extends Shape {\n    readonly type = ShapeType.RoundConvexPolygon;\n\n    /**\n     * The vertices of the convex polygon.\n     */\n    vertices: Float32Array;\n\n    /**\n     * Do we want to assume the vertices already form a convex hull?\n     */\n    skipConvexHullComputation: boolean;\n\n    /**\n     * The radius of the convex polygon's rounded edges and vertices.\n     */\n    borderRadius: number;\n\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param borderRadius - The radius of the borders of this convex polygon.\n     * @param skipConvexHullComputation - If set to `true`, the input points will\n     *   be assumed to form a convex polyline and no convex-hull computation will\n     *   be done automatically.\n     */\n    constructor(\n        vertices: Float32Array,\n        borderRadius: number,\n        skipConvexHullComputation: boolean,\n    ) {\n        super();\n        this.vertices = vertices;\n        this.borderRadius = borderRadius;\n        this.skipConvexHullComputation = !!skipConvexHullComputation;\n    }\n\n    public intoRaw(): RawShape {\n        if (this.skipConvexHullComputation) {\n            return RawShape.roundConvexPolyline(\n                this.vertices,\n                this.borderRadius,\n            );\n        } else {\n            return RawShape.roundConvexHull(this.vertices, this.borderRadius);\n        }\n    }\n}\n\n/**\n * A shape that is a heightfield.\n */\nexport class Heightfield extends Shape {\n    readonly type = ShapeType.HeightField;\n\n    /**\n     * The heights of the heightfield, along its local `y` axis.\n     */\n    heights: Float32Array;\n\n    /**\n     * The heightfield's length along its local `x` axis.\n     */\n    scale: Vector;\n\n    /**\n     * Creates a new heightfield shape.\n     *\n     * @param heights - The heights of the heightfield, along its local `y` axis.\n     * @param scale - The scale factor applied to the heightfield.\n     */\n    constructor(heights: Float32Array, scale: Vector) {\n        super();\n        this.heights = heights;\n        this.scale = scale;\n    }\n\n    public intoRaw(): RawShape {\n        let rawScale = VectorOps.intoRaw(this.scale);\n        let rawShape = RawShape.heightfield(this.heights, rawScale);\n        rawScale.free();\n        return rawShape;\n    }\n}\n\n// #endif\n\n", "import {RawPhysicsPipeline} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {\n    IntegrationParameters,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBodyHandle,\n    RigidBodySet,\n    CCDSolver,\n    IslandManager,\n} from \"../dynamics\";\nimport {\n    BroadPhase,\n    ColliderHandle,\n    ColliderSet,\n    NarrowPhase,\n} from \"../geometry\";\nimport {EventQueue} from \"./event_queue\";\nimport {PhysicsHooks} from \"./physics_hooks\";\n\nexport class PhysicsPipeline {\n    raw: RawPhysicsPipeline;\n\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawPhysicsPipeline) {\n        this.raw = raw || new RawPhysicsPipeline();\n    }\n\n    public step(\n        gravity: Vector,\n        integrationParameters: IntegrationParameters,\n        islands: IslandManager,\n        broadPhase: BroadPhase,\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        impulseJoints: ImpulseJointSet,\n        multibodyJoints: MultibodyJointSet,\n        ccdSolver: CCDSolver,\n        eventQueue?: EventQueue,\n        hooks?: PhysicsHooks,\n    ) {\n        let rawG = VectorOps.intoRaw(gravity);\n\n        if (!!eventQueue) {\n            this.raw.stepWithEvents(\n                rawG,\n                integrationParameters.raw,\n                islands.raw,\n                broadPhase.raw,\n                narrowPhase.raw,\n                bodies.raw,\n                colliders.raw,\n                impulseJoints.raw,\n                multibodyJoints.raw,\n                ccdSolver.raw,\n                eventQueue.raw,\n                hooks,\n                !!hooks ? hooks.filterContactPair : null,\n                !!hooks ? hooks.filterIntersectionPair : null,\n            );\n        } else {\n            this.raw.step(\n                rawG,\n                integrationParameters.raw,\n                islands.raw,\n                broadPhase.raw,\n                narrowPhase.raw,\n                bodies.raw,\n                colliders.raw,\n                impulseJoints.raw,\n                multibodyJoints.raw,\n                ccdSolver.raw,\n            );\n        }\n\n        rawG.free();\n    }\n}\n", "import {RawQueryPipeline, RawRayColliderIntersection} from \"../raw\";\nimport {\n    ColliderHandle,\n    ColliderSet,\n    InteractionGroups,\n    PointColliderProjection,\n    Ray,\n    RayColliderIntersection,\n    RayColliderHit,\n    Shape,\n    ColliderShapeCastHit,\n} from \"../geometry\";\nimport {IslandManager, RigidBodyHandle, RigidBodySet} from \"../dynamics\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\n\n// NOTE: must match the bits in the QueryFilterFlags on the Rust side.\n/**\n * Flags for excluding whole sets of colliders from a scene query.\n */\nexport enum QueryFilterFlags {\n    /**\n     * Exclude from the query any collider attached to a fixed rigid-body and colliders with no rigid-body attached.\n     */\n    EXCLUDE_FIXED = 0b0000_0001,\n    /**\n     * Exclude from the query any collider attached to a dynamic rigid-body.\n     */\n    EXCLUDE_KINEMATIC = 0b0000_0010,\n    /**\n     * Exclude from the query any collider attached to a kinematic rigid-body.\n     */\n    EXCLUDE_DYNAMIC = 0b0000_0100,\n    /**\n     * Exclude from the query any collider that is a sensor.\n     */\n    EXCLUDE_SENSORS = 0b0000_1000,\n    /**\n     * Exclude from the query any collider that is not a sensor.\n     */\n    EXCLUDE_SOLIDS = 0b0001_0000,\n    /**\n     * Excludes all colliders not attached to a dynamic rigid-body.\n     */\n    ONLY_DYNAMIC = QueryFilterFlags.EXCLUDE_FIXED |\n        QueryFilterFlags.EXCLUDE_KINEMATIC,\n    /**\n     * Excludes all colliders not attached to a kinematic rigid-body.\n     */\n    ONLY_KINEMATIC = QueryFilterFlags.EXCLUDE_DYNAMIC |\n        QueryFilterFlags.EXCLUDE_FIXED,\n    /**\n     * Exclude all colliders attached to a non-fixed rigid-body\n     * (this will not exclude colliders not attached to any rigid-body).\n     */\n    ONLY_FIXED = QueryFilterFlags.EXCLUDE_DYNAMIC |\n        QueryFilterFlags.EXCLUDE_KINEMATIC,\n}\n\n/**\n * A pipeline for performing queries on all the colliders of a scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class QueryPipeline {\n    raw: RawQueryPipeline;\n\n    /**\n     * Release the WASM memory occupied by this query pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawQueryPipeline) {\n        this.raw = raw || new RawQueryPipeline();\n    }\n\n    /**\n     * Updates the acceleration structure of the query pipeline.\n     * @param bodies - The set of rigid-bodies taking part in this pipeline.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     */\n    public update(bodies: RigidBodySet, colliders: ColliderSet) {\n        this.raw.update(bodies.raw, colliders.raw);\n    }\n\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    public castRay(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): RayColliderHit | null {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderHit.fromRaw(\n            colliders,\n            this.raw.castRay(\n                bodies.raw,\n                colliders.raw,\n                rawOrig,\n                rawDir,\n                maxToi,\n                solid,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    public castRayAndGetNormal(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): RayColliderIntersection | null {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderIntersection.fromRaw(\n            colliders,\n            this.raw.castRayAndGetNormal(\n                bodies.raw,\n                colliders.raw,\n                rawOrig,\n                rawDir,\n                maxToi,\n                solid,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    public intersectionsWithRay(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        callback: (intersect: RayColliderIntersection) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let rawCallback = (rawInter: RawRayColliderIntersection) => {\n            return callback(\n                RayColliderIntersection.fromRaw(colliders, rawInter),\n            );\n        };\n\n        this.raw.intersectionsWithRay(\n            bodies.raw,\n            colliders.raw,\n            rawOrig,\n            rawDir,\n            maxToi,\n            solid,\n            rawCallback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawOrig.free();\n        rawDir.free();\n    }\n\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    public intersectionWithShape(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): ColliderHandle | null {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n        let result = this.raw.intersectionWithShape(\n            bodies.raw,\n            colliders.raw,\n            rawPos,\n            rawRot,\n            rawShape,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPoint(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        point: Vector,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): PointColliderProjection | null {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(\n            colliders,\n            this.raw.projectPoint(\n                bodies.raw,\n                colliders.raw,\n                rawPoint,\n                solid,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPointAndGetFeature(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        point: Vector,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): PointColliderProjection | null {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(\n            colliders,\n            this.raw.projectPointAndGetFeature(\n                bodies.raw,\n                colliders.raw,\n                rawPoint,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    public intersectionsWithPoint(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        point: Vector,\n        callback: (handle: ColliderHandle) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ) {\n        let rawPoint = VectorOps.intoRaw(point);\n\n        this.raw.intersectionsWithPoint(\n            bodies.raw,\n            colliders.raw,\n            rawPoint,\n            callback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawPoint.free();\n    }\n\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param targetDistance  If the shape moves closer to this distance from a collider, a hit\n     *                       will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    public castShape(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shapeVel: Vector,\n        shape: Shape,\n        targetDistance: number,\n        maxToi: number,\n        stopAtPenetration: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): ColliderShapeCastHit | null {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawVel = VectorOps.intoRaw(shapeVel);\n        let rawShape = shape.intoRaw();\n\n        let result = ColliderShapeCastHit.fromRaw(\n            colliders,\n            this.raw.castShape(\n                bodies.raw,\n                colliders.raw,\n                rawPos,\n                rawRot,\n                rawVel,\n                rawShape,\n                targetDistance,\n                maxToi,\n                stopAtPenetration,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawVel.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    public intersectionsWithShape(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        callback: (handle: ColliderHandle) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n\n        this.raw.intersectionsWithShape(\n            bodies.raw,\n            colliders.raw,\n            rawPos,\n            rawRot,\n            rawShape,\n            callback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n    }\n\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    public collidersWithAabbIntersectingAabb(\n        aabbCenter: Vector,\n        aabbHalfExtents: Vector,\n        callback: (handle: ColliderHandle) => boolean,\n    ) {\n        let rawCenter = VectorOps.intoRaw(aabbCenter);\n        let rawHalfExtents = VectorOps.intoRaw(aabbHalfExtents);\n        this.raw.collidersWithAabbIntersectingAabb(\n            rawCenter,\n            rawHalfExtents,\n            callback,\n        );\n        rawCenter.free();\n        rawHalfExtents.free();\n    }\n}\n", "import {RawSerializationPipeline} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {\n    IntegrationParameters,\n    IslandManager,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {BroadPhase, ColliderSet, NarrowPhase} from \"../geometry\";\nimport {World} from \"./world\";\n\n/**\n * A pipeline for serializing the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class SerializationPipeline {\n    raw: RawSerializationPipeline;\n\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawSerializationPipeline) {\n        this.raw = raw || new RawSerializationPipeline();\n    }\n\n    /**\n     * Serialize a complete physics state into a single byte array.\n     * @param gravity - The current gravity affecting the simulation.\n     * @param integrationParameters - The integration parameters of the simulation.\n     * @param broadPhase - The broad-phase of the simulation.\n     * @param narrowPhase - The narrow-phase of the simulation.\n     * @param bodies - The rigid-bodies taking part into the simulation.\n     * @param colliders - The colliders taking part into the simulation.\n     * @param impulseJoints - The impulse joints taking part into the simulation.\n     * @param multibodyJoints - The multibody joints taking part into the simulation.\n     */\n    public serializeAll(\n        gravity: Vector,\n        integrationParameters: IntegrationParameters,\n        islands: IslandManager,\n        broadPhase: BroadPhase,\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        impulseJoints: ImpulseJointSet,\n        multibodyJoints: MultibodyJointSet,\n    ): Uint8Array {\n        let rawGra = VectorOps.intoRaw(gravity);\n\n        const res = this.raw.serializeAll(\n            rawGra,\n            integrationParameters.raw,\n            islands.raw,\n            broadPhase.raw,\n            narrowPhase.raw,\n            bodies.raw,\n            colliders.raw,\n            impulseJoints.raw,\n            multibodyJoints.raw,\n        );\n        rawGra.free();\n\n        return res;\n    }\n\n    /**\n     * Deserialize the complete physics state from a single byte array.\n     *\n     * @param data - The byte array to deserialize.\n     */\n    public deserializeAll(data: Uint8Array): World {\n        return World.fromRaw(this.raw.deserializeAll(data));\n    }\n}\n", "import {RawDebugRenderPipeline} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {\n    IntegrationParameters,\n    IslandManager,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {BroadPhase, ColliderSet, NarrowPhase} from \"../geometry\";\n\n/**\n * The vertex and color buffers for debug-redering the physics scene.\n */\nexport class DebugRenderBuffers {\n    /**\n     * The lines to render. This is a flat array containing all the lines\n     * to render. Each line is described as two consecutive point. Each\n     * point is described as two (in 2D) or three (in 3D) consecutive\n     * floats. For example, in 2D, the array: `[1, 2, 3, 4, 5, 6, 7, 8]`\n     * describes the two segments `[[1, 2], [3, 4]]` and `[[5, 6], [7, 8]]`.\n     */\n    public vertices: Float32Array;\n    /**\n     * The color buffer. There is one color per vertex, and each color\n     * has four consecutive components (in RGBA format).\n     */\n    public colors: Float32Array;\n\n    constructor(vertices: Float32Array, colors: Float32Array) {\n        this.vertices = vertices;\n        this.colors = colors;\n    }\n}\n\n/**\n * A pipeline for rendering the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `debugRenderPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class DebugRenderPipeline {\n    raw: RawDebugRenderPipeline;\n    public vertices: Float32Array;\n    public colors: Float32Array;\n\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        this.vertices = undefined;\n        this.colors = undefined;\n    }\n\n    constructor(raw?: RawDebugRenderPipeline) {\n        this.raw = raw || new RawDebugRenderPipeline();\n    }\n\n    public render(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        impulse_joints: ImpulseJointSet,\n        multibody_joints: MultibodyJointSet,\n        narrow_phase: NarrowPhase,\n    ) {\n        this.raw.render(\n            bodies.raw,\n            colliders.raw,\n            impulse_joints.raw,\n            multibody_joints.raw,\n            narrow_phase.raw,\n        );\n        this.vertices = this.raw.vertices();\n        this.colors = this.raw.colors();\n    }\n}\n", "import {RawKinematicCharacterController, RawCharacterCollision} from \"../raw\";\nimport {Rotation, Vector, VectorOps} from \"../math\";\nimport {Collider, ColliderSet, InteractionGroups, Shape} from \"../geometry\";\nimport {QueryFilterFlags, QueryPipeline, World} from \"../pipeline\";\nimport {IntegrationParameters, RigidBody, RigidBodySet} from \"../dynamics\";\n\n/**\n * A collision between the character and an obstacle hit on its path.\n */\nexport class CharacterCollision {\n    /** The collider involved in the collision. Null if the collider no longer exists in the physics world. */\n    public collider: Collider | null;\n    /** The translation delta applied to the character before this collision took place. */\n    public translationDeltaApplied: Vector;\n    /** The translation delta the character would move after this collision if there is no other obstacles. */\n    public translationDeltaRemaining: Vector;\n    /** The time-of-impact between the character and the obstacles. */\n    public toi: number;\n    /** The world-space contact point on the collider when the collision happens. */\n    public witness1: Vector;\n    /** The local-space contact point on the character when the collision happens. */\n    public witness2: Vector;\n    /** The world-space outward contact normal on the collider when the collision happens. */\n    public normal1: Vector;\n    /** The local-space outward contact normal on the character when the collision happens. */\n    public normal2: Vector;\n}\n\n/**\n * A character controller for controlling kinematic bodies and parentless colliders by hitting\n * and sliding against obstacles.\n */\nexport class KinematicCharacterController {\n    private raw: RawKinematicCharacterController;\n    private rawCharacterCollision: RawCharacterCollision;\n\n    private params: IntegrationParameters;\n    private bodies: RigidBodySet;\n    private colliders: ColliderSet;\n    private queries: QueryPipeline;\n    private _applyImpulsesToDynamicBodies: boolean;\n    private _characterMass: number | null;\n\n    constructor(\n        offset: number,\n        params: IntegrationParameters,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        queries: QueryPipeline,\n    ) {\n        this.params = params;\n        this.bodies = bodies;\n        this.colliders = colliders;\n        this.queries = queries;\n        this.raw = new RawKinematicCharacterController(offset);\n        this.rawCharacterCollision = new RawCharacterCollision();\n        this._applyImpulsesToDynamicBodies = false;\n        this._characterMass = null;\n    }\n\n    /** @internal */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n            this.rawCharacterCollision.free();\n        }\n\n        this.raw = undefined;\n        this.rawCharacterCollision = undefined;\n    }\n\n    /**\n     * The direction that goes \"up\". Used to determine where the floor is, and the floors angle.\n     */\n    public up(): Vector {\n        return this.raw.up();\n    }\n\n    /**\n     * Sets the direction that goes \"up\". Used to determine where the floor is, and the floors angle.\n     */\n    public setUp(vector: Vector) {\n        let rawVect = VectorOps.intoRaw(vector);\n        return this.raw.setUp(rawVect);\n        rawVect.free();\n    }\n\n    public applyImpulsesToDynamicBodies(): boolean {\n        return this._applyImpulsesToDynamicBodies;\n    }\n\n    public setApplyImpulsesToDynamicBodies(enabled: boolean) {\n        this._applyImpulsesToDynamicBodies = enabled;\n    }\n\n    /**\n     * Returns the custom value of the character mass, if it was set by `this.setCharacterMass`.\n     */\n    public characterMass(): number | null {\n        return this._characterMass;\n    }\n\n    /**\n     * Set the mass of the character to be used for impulse resolution if `self.applyImpulsesToDynamicBodies`\n     * is set to `true`.\n     *\n     * If no character mass is set explicitly (or if it is set to `null`) it is automatically assumed to be equal\n     * to the mass of the rigid-body the character collider is attached to; or equal to 0 if the character collider\n     * isnt attached to any rigid-body.\n     *\n     * @param mass - The mass to set.\n     */\n    public setCharacterMass(mass: number | null) {\n        this._characterMass = mass;\n    }\n\n    /**\n     * A small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldnt be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    public offset(): number {\n        return this.raw.offset();\n    }\n\n    /**\n     * Sets a small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldnt be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    public setOffset(value: number) {\n        this.raw.setOffset(value);\n    }\n\n    /// Increase this number if your character appears to get stuck when sliding against surfaces.\n    ///\n    /// This is a small distance applied to the movement toward the contact normals of shapes hit\n    /// by the character controller. This helps shape-casting not getting stuck in an always-penetrating\n    /// state during the sliding calculation.\n    ///\n    /// This value should remain fairly small since it can introduce artificial \"bumps\" when sliding\n    /// along a flat surface.\n    public normalNudgeFactor(): number {\n        return this.raw.normalNudgeFactor();\n    }\n\n    /// Increase this number if your character appears to get stuck when sliding against surfaces.\n    ///\n    /// This is a small distance applied to the movement toward the contact normals of shapes hit\n    /// by the character controller. This helps shape-casting not getting stuck in an always-penetrating\n    /// state during the sliding calculation.\n    ///\n    /// This value should remain fairly small since it can introduce artificial \"bumps\" when sliding\n    /// along a flat surface.\n    public setNormalNudgeFactor(value: number) {\n        this.raw.setNormalNudgeFactor(value);\n    }\n\n    /**\n     * Is sliding against obstacles enabled?\n     */\n    public slideEnabled(): boolean {\n        return this.raw.slideEnabled();\n    }\n\n    /**\n     * Enable or disable sliding against obstacles.\n     */\n    public setSlideEnabled(enabled: boolean) {\n        this.raw.setSlideEnabled(enabled);\n    }\n\n    /**\n     * The maximum step height a character can automatically step over.\n     */\n    public autostepMaxHeight(): number | null {\n        return this.raw.autostepMaxHeight();\n    }\n\n    /**\n     * The minimum width of free space that must be available after stepping on a stair.\n     */\n    public autostepMinWidth(): number | null {\n        return this.raw.autostepMinWidth();\n    }\n\n    /**\n     * Can the character automatically step over dynamic bodies too?\n     */\n    public autostepIncludesDynamicBodies(): boolean | null {\n        return this.raw.autostepIncludesDynamicBodies();\n    }\n\n    /**\n     * Is automatically stepping over small objects enabled?\n     */\n    public autostepEnabled(): boolean {\n        return this.raw.autostepEnabled();\n    }\n\n    /**\n     * Enabled automatically stepping over small objects.\n     *\n     * @param maxHeight - The maximum step height a character can automatically step over.\n     * @param minWidth - The minimum width of free space that must be available after stepping on a stair.\n     * @param includeDynamicBodies - Can the character automatically step over dynamic bodies too?\n     */\n    public enableAutostep(\n        maxHeight: number,\n        minWidth: number,\n        includeDynamicBodies: boolean,\n    ) {\n        this.raw.enableAutostep(maxHeight, minWidth, includeDynamicBodies);\n    }\n\n    /**\n     * Disable automatically stepping over small objects.\n     */\n    public disableAutostep() {\n        return this.raw.disableAutostep();\n    }\n\n    /**\n     * The maximum angle (radians) between the floors normal and the `up` vector that the\n     * character is able to climb.\n     */\n    public maxSlopeClimbAngle(): number {\n        return this.raw.maxSlopeClimbAngle();\n    }\n\n    /**\n     * Sets the maximum angle (radians) between the floors normal and the `up` vector that the\n     * character is able to climb.\n     */\n    public setMaxSlopeClimbAngle(angle: number) {\n        this.raw.setMaxSlopeClimbAngle(angle);\n    }\n\n    /**\n     * The minimum angle (radians) between the floors normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    public minSlopeSlideAngle(): number {\n        return this.raw.minSlopeSlideAngle();\n    }\n\n    /**\n     * Sets the minimum angle (radians) between the floors normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    public setMinSlopeSlideAngle(angle: number) {\n        this.raw.setMinSlopeSlideAngle(angle);\n    }\n\n    /**\n     * If snap-to-ground is enabled, should the character be automatically snapped to the ground if\n     * the distance between the ground and its feet are smaller than the specified threshold?\n     */\n    public snapToGroundDistance(): number | null {\n        return this.raw.snapToGroundDistance();\n    }\n\n    /**\n     * Enables automatically snapping the character to the ground if the distance between\n     * the ground and its feet are smaller than the specified threshold.\n     */\n    public enableSnapToGround(distance: number) {\n        this.raw.enableSnapToGround(distance);\n    }\n\n    /**\n     * Disables automatically snapping the character to the ground.\n     */\n    public disableSnapToGround() {\n        this.raw.disableSnapToGround();\n    }\n\n    /**\n     * Is automatically snapping the character to the ground enabled?\n     */\n    public snapToGroundEnabled(): boolean {\n        return this.raw.snapToGroundEnabled();\n    }\n\n    /**\n     * Computes the movement the given collider is able to execute after hitting and sliding on obstacles.\n     *\n     * @param collider - The collider to move.\n     * @param desiredTranslationDelta - The desired collider movement.\n     * @param filterFlags - Flags for excluding whole subsets of colliders from the obstacles taken into account.\n     * @param filterGroups - Groups for excluding colliders with incompatible collision groups from the obstacles\n     *                       taken into account.\n     * @param filterPredicate - Any collider for which this closure returns `false` will be excluded from the\n     *                          obstacles taken into account.\n     */\n    public computeColliderMovement(\n        collider: Collider,\n        desiredTranslationDelta: Vector,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        let rawTranslationDelta = VectorOps.intoRaw(desiredTranslationDelta);\n        this.raw.computeColliderMovement(\n            this.params.dt,\n            this.bodies.raw,\n            this.colliders.raw,\n            this.queries.raw,\n            collider.handle,\n            rawTranslationDelta,\n            this._applyImpulsesToDynamicBodies,\n            this._characterMass,\n            filterFlags,\n            filterGroups,\n            this.colliders.castClosure(filterPredicate),\n        );\n        rawTranslationDelta.free();\n    }\n\n    /**\n     * The movement computed by the last call to `this.computeColliderMovement`.\n     */\n    public computedMovement(): Vector {\n        return VectorOps.fromRaw(this.raw.computedMovement());\n    }\n\n    /**\n     * The result of ground detection computed by the last call to `this.computeColliderMovement`.\n     */\n    public computedGrounded(): boolean {\n        return this.raw.computedGrounded();\n    }\n\n    /**\n     * The number of collisions against obstacles detected along the path of the last call\n     * to `this.computeColliderMovement`.\n     */\n    public numComputedCollisions(): number {\n        return this.raw.numComputedCollisions();\n    }\n\n    /**\n     * Returns the collision against one of the obstacles detected along the path of the last\n     * call to `this.computeColliderMovement`.\n     *\n     * @param i - The i-th collision will be returned.\n     * @param out - If this argument is set, it will be filled with the collision information.\n     */\n    public computedCollision(\n        i: number,\n        out?: CharacterCollision,\n    ): CharacterCollision | null {\n        if (!this.raw.computedCollision(i, this.rawCharacterCollision)) {\n            return null;\n        } else {\n            let c = this.rawCharacterCollision;\n            out = out ?? new CharacterCollision();\n            out.translationDeltaApplied = VectorOps.fromRaw(\n                c.translationDeltaApplied(),\n            );\n            out.translationDeltaRemaining = VectorOps.fromRaw(\n                c.translationDeltaRemaining(),\n            );\n            out.toi = c.toi();\n            out.witness1 = VectorOps.fromRaw(c.worldWitness1());\n            out.witness2 = VectorOps.fromRaw(c.worldWitness2());\n            out.normal1 = VectorOps.fromRaw(c.worldNormal1());\n            out.normal2 = VectorOps.fromRaw(c.worldNormal2());\n            out.collider = this.colliders.get(c.handle());\n            return out;\n        }\n    }\n}\n", "import {\n    RawBroadPhase,\n    RawCCDSolver,\n    RawColliderSet,\n    RawDeserializedWorld,\n    RawIntegrationParameters,\n    RawIslandManager,\n    RawImpulseJointSet,\n    RawMultibodyJointSet,\n    RawNarrowPhase,\n    RawPhysicsPipeline,\n    RawQueryPipeline,\n    RawRigidBodySet,\n    RawSerializationPipeline,\n    RawDebugRenderPipeline,\n} from \"../raw\";\n\nimport {\n    BroadPhase,\n    Collider,\n    ColliderDesc,\n    ColliderHandle,\n    ColliderSet,\n    InteractionGroups,\n    NarrowPhase,\n    PointColliderProjection,\n    Ray,\n    RayColliderIntersection,\n    RayColliderHit,\n    Shape,\n    ColliderShapeCastHit,\n    TempContactManifold,\n} from \"../geometry\";\nimport {\n    CCDSolver,\n    IntegrationParameters,\n    IslandManager,\n    ImpulseJoint,\n    ImpulseJointHandle,\n    MultibodyJoint,\n    MultibodyJointHandle,\n    JointData,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBody,\n    RigidBodyDesc,\n    RigidBodyHandle,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {Rotation, Vector, VectorOps} from \"../math\";\nimport {PhysicsPipeline} from \"./physics_pipeline\";\nimport {QueryFilterFlags, QueryPipeline} from \"./query_pipeline\";\nimport {SerializationPipeline} from \"./serialization_pipeline\";\nimport {EventQueue} from \"./event_queue\";\nimport {PhysicsHooks} from \"./physics_hooks\";\nimport {DebugRenderBuffers, DebugRenderPipeline} from \"./debug_render_pipeline\";\nimport {KinematicCharacterController} from \"../control\";\nimport {Coarena} from \"../coarena\";\n\n\n/**\n * The physics world.\n *\n * This contains all the data-structures necessary for creating and simulating\n * bodies with contacts, joints, and external forces.\n */\nexport class World {\n    public gravity: Vector;\n    integrationParameters: IntegrationParameters;\n    islands: IslandManager;\n    broadPhase: BroadPhase;\n    narrowPhase: NarrowPhase;\n    bodies: RigidBodySet;\n    colliders: ColliderSet;\n    impulseJoints: ImpulseJointSet;\n    multibodyJoints: MultibodyJointSet;\n    ccdSolver: CCDSolver;\n    queryPipeline: QueryPipeline;\n    physicsPipeline: PhysicsPipeline;\n    serializationPipeline: SerializationPipeline;\n    debugRenderPipeline: DebugRenderPipeline;\n    characterControllers: Set<KinematicCharacterController>;\n\n\n    /**\n     * Release the WASM memory occupied by this physics world.\n     *\n     * All the fields of this physics world will be freed as well,\n     * so there is no need to call their `.free()` methods individually.\n     */\n    public free() {\n        this.integrationParameters.free();\n        this.islands.free();\n        this.broadPhase.free();\n        this.narrowPhase.free();\n        this.bodies.free();\n        this.colliders.free();\n        this.impulseJoints.free();\n        this.multibodyJoints.free();\n        this.ccdSolver.free();\n        this.queryPipeline.free();\n        this.physicsPipeline.free();\n        this.serializationPipeline.free();\n        this.debugRenderPipeline.free();\n        this.characterControllers.forEach((controller) => controller.free());\n\n\n        this.integrationParameters = undefined;\n        this.islands = undefined;\n        this.broadPhase = undefined;\n        this.narrowPhase = undefined;\n        this.bodies = undefined;\n        this.colliders = undefined;\n        this.ccdSolver = undefined;\n        this.impulseJoints = undefined;\n        this.multibodyJoints = undefined;\n        this.queryPipeline = undefined;\n        this.physicsPipeline = undefined;\n        this.serializationPipeline = undefined;\n        this.debugRenderPipeline = undefined;\n        this.characterControllers = undefined;\n\n    }\n\n    constructor(\n        gravity: Vector,\n        rawIntegrationParameters?: RawIntegrationParameters,\n        rawIslands?: RawIslandManager,\n        rawBroadPhase?: RawBroadPhase,\n        rawNarrowPhase?: RawNarrowPhase,\n        rawBodies?: RawRigidBodySet,\n        rawColliders?: RawColliderSet,\n        rawImpulseJoints?: RawImpulseJointSet,\n        rawMultibodyJoints?: RawMultibodyJointSet,\n        rawCCDSolver?: RawCCDSolver,\n        rawQueryPipeline?: RawQueryPipeline,\n        rawPhysicsPipeline?: RawPhysicsPipeline,\n        rawSerializationPipeline?: RawSerializationPipeline,\n        rawDebugRenderPipeline?: RawDebugRenderPipeline,\n    ) {\n        this.gravity = gravity;\n        this.integrationParameters = new IntegrationParameters(\n            rawIntegrationParameters,\n        );\n        this.islands = new IslandManager(rawIslands);\n        this.broadPhase = new BroadPhase(rawBroadPhase);\n        this.narrowPhase = new NarrowPhase(rawNarrowPhase);\n        this.bodies = new RigidBodySet(rawBodies);\n        this.colliders = new ColliderSet(rawColliders);\n        this.impulseJoints = new ImpulseJointSet(rawImpulseJoints);\n        this.multibodyJoints = new MultibodyJointSet(rawMultibodyJoints);\n        this.ccdSolver = new CCDSolver(rawCCDSolver);\n        this.queryPipeline = new QueryPipeline(rawQueryPipeline);\n        this.physicsPipeline = new PhysicsPipeline(rawPhysicsPipeline);\n        this.serializationPipeline = new SerializationPipeline(\n            rawSerializationPipeline,\n        );\n        this.debugRenderPipeline = new DebugRenderPipeline(\n            rawDebugRenderPipeline,\n        );\n        this.characterControllers = new Set<KinematicCharacterController>();\n\n\n        this.impulseJoints.finalizeDeserialization(this.bodies);\n        this.bodies.finalizeDeserialization(this.colliders);\n        this.colliders.finalizeDeserialization(this.bodies);\n    }\n\n    public static fromRaw(raw: RawDeserializedWorld): World {\n        if (!raw) return null;\n\n        return new World(\n            VectorOps.fromRaw(raw.takeGravity()),\n            raw.takeIntegrationParameters(),\n            raw.takeIslandManager(),\n            raw.takeBroadPhase(),\n            raw.takeNarrowPhase(),\n            raw.takeBodies(),\n            raw.takeColliders(),\n            raw.takeImpulseJoints(),\n            raw.takeMultibodyJoints(),\n        );\n    }\n\n    /**\n     * Takes a snapshot of this world.\n     *\n     * Use `World.restoreSnapshot` to create a new physics world with a state identical to\n     * the state when `.takeSnapshot()` is called.\n     */\n    public takeSnapshot(): Uint8Array {\n        return this.serializationPipeline.serializeAll(\n            this.gravity,\n            this.integrationParameters,\n            this.islands,\n            this.broadPhase,\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            this.impulseJoints,\n            this.multibodyJoints,\n        );\n    }\n\n    /**\n     * Creates a new physics world from a snapshot.\n     *\n     * This new physics world will be an identical copy of the snapshoted physics world.\n     */\n    public static restoreSnapshot(data: Uint8Array): World {\n        let deser = new SerializationPipeline();\n        return deser.deserializeAll(data);\n    }\n\n    /**\n     * Computes all the lines (and their colors) needed to render the scene.\n     */\n    public debugRender(): DebugRenderBuffers {\n        this.debugRenderPipeline.render(\n            this.bodies,\n            this.colliders,\n            this.impulseJoints,\n            this.multibodyJoints,\n            this.narrowPhase,\n        );\n        return new DebugRenderBuffers(\n            this.debugRenderPipeline.vertices,\n            this.debugRenderPipeline.colors,\n        );\n    }\n\n    /**\n     * Advance the simulation by one time step.\n     *\n     * All events generated by the physics engine are ignored.\n     *\n     * @param EventQueue - (optional) structure responsible for collecting\n     *   events generated by the physics engine.\n     */\n    public step(eventQueue?: EventQueue, hooks?: PhysicsHooks) {\n        this.physicsPipeline.step(\n            this.gravity,\n            this.integrationParameters,\n            this.islands,\n            this.broadPhase,\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            this.impulseJoints,\n            this.multibodyJoints,\n            this.ccdSolver,\n            eventQueue,\n            hooks,\n        );\n        this.queryPipeline.update(this.bodies, this.colliders);\n    }\n\n    /**\n     * Update colliders positions after rigid-bodies moved.\n     *\n     * When a rigid-body moves, the positions of the colliders attached to it need to be updated. This update is\n     * generally automatically done at the beginning and the end of each simulation step with World.step.\n     * If the positions need to be updated without running a simulation step this method can be called manually.\n     */\n    public propagateModifiedBodyPositionsToColliders() {\n        this.bodies.raw.propagateModifiedBodyPositionsToColliders(\n            this.colliders.raw,\n        );\n    }\n\n    /**\n     * Ensure subsequent scene queries take into account the collider positions set before this method is called.\n     *\n     * This does not step the physics simulation forward.\n     */\n    public updateSceneQueries() {\n        this.propagateModifiedBodyPositionsToColliders();\n        this.queryPipeline.update(this.bodies, this.colliders);\n    }\n\n    /**\n     * The current simulation timestep.\n     */\n    get timestep(): number {\n        return this.integrationParameters.dt;\n    }\n\n    /**\n     * Sets the new simulation timestep.\n     *\n     * The simulation timestep governs by how much the physics state of the world will\n     * be integrated. A simulation timestep should:\n     * - be as small as possible. Typical values evolve around 0.016 (assuming the chosen unit is milliseconds,\n     * corresponds to the time between two frames of a game running at 60FPS).\n     * - not vary too much during the course of the simulation. A timestep with large variations may\n     * cause instabilities in the simulation.\n     *\n     * @param dt - The timestep length, in seconds.\n     */\n    set timestep(dt: number) {\n        this.integrationParameters.dt = dt;\n    }\n\n    /**\n     * The approximate size of most dynamic objects in the scene.\n     *\n     * See the documentation of the `World.lengthUnit` setter for further details.\n     */\n    get lengthUnit(): number {\n        return this.integrationParameters.lengthUnit;\n    }\n\n    /**\n     * The approximate size of most dynamic objects in the scene.\n     *\n     * This value is used internally to estimate some length-based tolerance. In particular, the\n     * values `IntegrationParameters.allowedLinearError`,\n     * `IntegrationParameters.maxPenetrationCorrection`,\n     * `IntegrationParameters.predictionDistance`, `RigidBodyActivation.linearThreshold`\n     * are scaled by this value implicitly.\n     *\n     * This value can be understood as the number of units-per-meter in your physical world compared\n     * to a human-sized world in meter. For example, in a 2d game, if your typical object size is 100\n     * pixels, set the `[`Self::length_unit`]` parameter to 100.0. The physics engine will interpret\n     * it as if 100 pixels is equivalent to 1 meter in its various internal threshold.\n     * (default `1.0`).\n     */\n    set lengthUnit(unitsPerMeter: number) {\n        this.integrationParameters.lengthUnit = unitsPerMeter;\n    }\n\n    /**\n     * The number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    get numSolverIterations(): number {\n        return this.integrationParameters.numSolverIterations;\n    }\n\n    /**\n     * Sets the number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     *\n     * The greater this value is, the most rigid and realistic the physics simulation will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new number of solver iterations.\n     */\n    set numSolverIterations(niter: number) {\n        this.integrationParameters.numSolverIterations = niter;\n    }\n\n    /**\n     * Number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    get numAdditionalFrictionIterations(): number {\n        return this.integrationParameters.numAdditionalFrictionIterations;\n    }\n\n    /**\n     * Sets the number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     *\n     * The greater this value is, the most realistic friction will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new number of additional friction iterations.\n     */\n    set numAdditionalFrictionIterations(niter: number) {\n        this.integrationParameters.numAdditionalFrictionIterations = niter;\n    }\n\n    /**\n     * Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    get numInternalPgsIterations(): number {\n        return this.integrationParameters.numInternalPgsIterations;\n    }\n\n    /**\n     * Sets the Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     *\n     * Increasing this parameter will improve stability of the simulation. It will have a lesser effect than\n     * increasing `numSolverIterations` but is also less computationally expensive.\n     *\n     * @param niter - The new number of internal PGS iterations.\n     */\n    set numInternalPgsIterations(niter: number) {\n        this.integrationParameters.numInternalPgsIterations = niter;\n    }\n\n    /// Configures the integration parameters to match the old PGS solver\n    /// from Rapier JS version <= 0.11.\n    ///\n    /// This solver was slightly faster than the new one but resulted\n    /// in less stable joints and worse convergence rates.\n    ///\n    /// This should only be used for comparison purpose or if you are\n    /// experiencing problems with the new solver.\n    ///\n    /// NOTE: this does not affect any `RigidBody.additional_solver_iterations` that will\n    ///       still create solver iterations based on the new \"small-steps\" PGS solver.\n    public switchToStandardPgsSolver() {\n        this.integrationParameters.switchToStandardPgsSolver();\n    }\n\n    /// Configures the integration parameters to match the new \"small-steps\" PGS solver\n    /// from Rapier version >= 0.12.\n    ///\n    /// The \"small-steps\" PGS solver is the default one when creating the physics world. So\n    /// calling this function is generally not needed unless `World.switch_to_standard_pgs_solver`\n    /// was called.\n    ///\n    /// This solver results in more stable joints and significantly better convergence\n    /// rates but is slightly slower in its default settings.\n    public switchToSmallStepsPgsSolver() {\n        this.integrationParameters.switchToSmallStepsPgsSolver();\n    }\n\n    /// Configures the integration parameters to match the new \"small-steps\" PGS solver\n    /// from Rapier version >= 0.12. Warmstarting is disabled.\n    ///\n    /// The \"small-steps\" PGS solver is the default one when creating the physics world. So\n    /// calling this function is generally not needed unless `World.switch_to_standard_pgs_solver`\n    /// was called.\n    ///\n    /// This solver results in more stable joints and significantly better convergence\n    /// rates but is slightly slower in its default settings.\n    public switchToSmallStepsPgsSolverWithoutWarmstart() {\n        this.integrationParameters.switchToSmallStepsPgsSolverWithoutWarmstart();\n    }\n\n    /**\n     * Creates a new rigid-body from the given rigid-body descriptor.\n     *\n     * @param body - The description of the rigid-body to create.\n     */\n    public createRigidBody(body: RigidBodyDesc): RigidBody {\n        return this.bodies.createRigidBody(this.colliders, body);\n    }\n\n    /**\n     * Creates a new character controller.\n     *\n     * @param offset - The artificial gap added between the characters chape and its environment.\n     */\n    public createCharacterController(\n        offset: number,\n    ): KinematicCharacterController {\n        let controller = new KinematicCharacterController(\n            offset,\n            this.integrationParameters,\n            this.bodies,\n            this.colliders,\n            this.queryPipeline,\n        );\n        this.characterControllers.add(controller);\n        return controller;\n    }\n\n    /**\n     * Removes a character controller from this world.\n     *\n     * @param controller - The character controller to remove.\n     */\n    public removeCharacterController(controller: KinematicCharacterController) {\n        this.characterControllers.delete(controller);\n        controller.free();\n    }\n\n\n    /**\n     * Creates a new collider.\n     *\n     * @param desc - The description of the collider.\n     * @param parent - The rigid-body this collider is attached to.\n     */\n    public createCollider(desc: ColliderDesc, parent?: RigidBody): Collider {\n        let parentHandle = parent ? parent.handle : undefined;\n        return this.colliders.createCollider(this.bodies, desc, parentHandle);\n    }\n\n    /**\n     * Creates a new impulse joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createImpulseJoint(\n        params: JointData,\n        parent1: RigidBody,\n        parent2: RigidBody,\n        wakeUp: boolean,\n    ): ImpulseJoint {\n        return this.impulseJoints.createJoint(\n            this.bodies,\n            params,\n            parent1.handle,\n            parent2.handle,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Creates a new multibody joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createMultibodyJoint(\n        params: JointData,\n        parent1: RigidBody,\n        parent2: RigidBody,\n        wakeUp: boolean,\n    ): MultibodyJoint {\n        return this.multibodyJoints.createJoint(\n            params,\n            parent1.handle,\n            parent2.handle,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Retrieves a rigid-body from its handle.\n     *\n     * @param handle - The integer handle of the rigid-body to retrieve.\n     */\n    public getRigidBody(handle: RigidBodyHandle): RigidBody {\n        return this.bodies.get(handle);\n    }\n\n    /**\n     * Retrieves a collider from its handle.\n     *\n     * @param handle - The integer handle of the collider to retrieve.\n     */\n    public getCollider(handle: ColliderHandle): Collider {\n        return this.colliders.get(handle);\n    }\n\n    /**\n     * Retrieves an impulse joint from its handle.\n     *\n     * @param handle - The integer handle of the impulse joint to retrieve.\n     */\n    public getImpulseJoint(handle: ImpulseJointHandle): ImpulseJoint {\n        return this.impulseJoints.get(handle);\n    }\n\n    /**\n     * Retrieves an multibody joint from its handle.\n     *\n     * @param handle - The integer handle of the multibody joint to retrieve.\n     */\n    public getMultibodyJoint(handle: MultibodyJointHandle): MultibodyJoint {\n        return this.multibodyJoints.get(handle);\n    }\n\n    /**\n     * Removes the given rigid-body from this physics world.\n     *\n     * This will remove this rigid-body as well as all its attached colliders and joints.\n     * Every other bodies touching or attached by joints to this rigid-body will be woken-up.\n     *\n     * @param body - The rigid-body to remove.\n     */\n    public removeRigidBody(body: RigidBody) {\n        if (this.bodies) {\n            this.bodies.remove(\n                body.handle,\n                this.islands,\n                this.colliders,\n                this.impulseJoints,\n                this.multibodyJoints,\n            );\n        }\n    }\n\n    /**\n     * Removes the given collider from this physics world.\n     *\n     * @param collider - The collider to remove.\n     * @param wakeUp - If set to `true`, the rigid-body this collider is attached to will be awaken.\n     */\n    public removeCollider(collider: Collider, wakeUp: boolean) {\n        if (this.colliders) {\n            this.colliders.remove(\n                collider.handle,\n                this.islands,\n                this.bodies,\n                wakeUp,\n            );\n        }\n    }\n\n    /**\n     * Removes the given impulse joint from this physics world.\n     *\n     * @param joint - The impulse joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    public removeImpulseJoint(joint: ImpulseJoint, wakeUp: boolean) {\n        if (this.impulseJoints) {\n            this.impulseJoints.remove(joint.handle, wakeUp);\n        }\n    }\n\n    /**\n     * Removes the given multibody joint from this physics world.\n     *\n     * @param joint - The multibody joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    public removeMultibodyJoint(joint: MultibodyJoint, wakeUp: boolean) {\n        if (this.impulseJoints) {\n            this.multibodyJoints.remove(joint.handle, wakeUp);\n        }\n    }\n\n    /**\n     * Applies the given closure to each collider managed by this physics world.\n     *\n     * @param f(collider) - The function to apply to each collider managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachCollider(f: (collider: Collider) => void) {\n        this.colliders.forEach(f);\n    }\n\n    /**\n     * Applies the given closure to each rigid-body managed by this physics world.\n     *\n     * @param f(body) - The function to apply to each rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachRigidBody(f: (body: RigidBody) => void) {\n        this.bodies.forEach(f);\n    }\n\n    /**\n     * Applies the given closure to each active rigid-body managed by this physics world.\n     *\n     * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n     * the physics engine in order to save computational power. A sleeping rigid-body never moves\n     * unless it is moved manually by the user.\n     *\n     * @param f - The function to apply to each active rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachActiveRigidBody(f: (body: RigidBody) => void) {\n        this.bodies.forEachActiveRigidBody(this.islands, f);\n    }\n\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    public castRay(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): RayColliderHit | null {\n        return this.queryPipeline.castRay(\n            this.bodies,\n            this.colliders,\n            ray,\n            maxToi,\n            solid,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    public castRayAndGetNormal(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): RayColliderIntersection | null {\n        return this.queryPipeline.castRayAndGetNormal(\n            this.bodies,\n            this.colliders,\n            ray,\n            maxToi,\n            solid,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    public intersectionsWithRay(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        callback: (intersect: RayColliderIntersection) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        this.queryPipeline.intersectionsWithRay(\n            this.bodies,\n            this.colliders,\n            ray,\n            maxToi,\n            solid,\n            callback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    public intersectionWithShape(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): Collider | null {\n        let handle = this.queryPipeline.intersectionWithShape(\n            this.bodies,\n            this.colliders,\n            shapePos,\n            shapeRot,\n            shape,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n        return handle != null ? this.colliders.get(handle) : null;\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPoint(\n        point: Vector,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): PointColliderProjection | null {\n        return this.queryPipeline.projectPoint(\n            this.bodies,\n            this.colliders,\n            point,\n            solid,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPointAndGetFeature(\n        point: Vector,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): PointColliderProjection | null {\n        return this.queryPipeline.projectPointAndGetFeature(\n            this.bodies,\n            this.colliders,\n            point,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    public intersectionsWithPoint(\n        point: Vector,\n        callback: (handle: Collider) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        this.queryPipeline.intersectionsWithPoint(\n            this.bodies,\n            this.colliders,\n            point,\n            this.colliders.castClosure(callback),\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param targetDistance  If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    public castShape(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shapeVel: Vector,\n        shape: Shape,\n        targetDistance: number,\n        maxToi: number,\n        stopAtPenetration: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): ColliderShapeCastHit | null {\n        return this.queryPipeline.castShape(\n            this.bodies,\n            this.colliders,\n            shapePos,\n            shapeRot,\n            shapeVel,\n            shape,\n            targetDistance,\n            maxToi,\n            stopAtPenetration,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    public intersectionsWithShape(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        callback: (collider: Collider) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        this.queryPipeline.intersectionsWithShape(\n            this.bodies,\n            this.colliders,\n            shapePos,\n            shapeRot,\n            shape,\n            this.colliders.castClosure(callback),\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    public collidersWithAabbIntersectingAabb(\n        aabbCenter: Vector,\n        aabbHalfExtents: Vector,\n        callback: (handle: Collider) => boolean,\n    ) {\n        this.queryPipeline.collidersWithAabbIntersectingAabb(\n            aabbCenter,\n            aabbHalfExtents,\n            this.colliders.castClosure(callback),\n        );\n    }\n\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    public contactPairsWith(\n        collider1: Collider,\n        f: (collider2: Collider) => void,\n    ) {\n        this.narrowPhase.contactPairsWith(\n            collider1.handle,\n            this.colliders.castClosure(f),\n        );\n    }\n\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    public intersectionPairsWith(\n        collider1: Collider,\n        f: (collider2: Collider) => void,\n    ) {\n        this.narrowPhase.intersectionPairsWith(\n            collider1.handle,\n            this.colliders.castClosure(f),\n        );\n    }\n\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    public contactPair(\n        collider1: Collider,\n        collider2: Collider,\n        f: (manifold: TempContactManifold, flipped: boolean) => void,\n    ) {\n        this.narrowPhase.contactPair(collider1.handle, collider2.handle, f);\n    }\n\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1  The first collider involved in the intersection.\n     * @param collider2  The second collider involved in the intersection.\n     */\n    public intersectionPair(collider1: Collider, collider2: Collider): boolean {\n        return this.narrowPhase.intersectionPair(\n            collider1.handle,\n            collider2.handle,\n        );\n    }\n}\n", "import {RawContactForceEvent, RawEventQueue} from \"../raw\";\nimport {RigidBodyHandle} from \"../dynamics\";\nimport {Collider, ColliderHandle} from \"../geometry\";\nimport {Vector, VectorOps} from \"../math\";\n\n/**\n * Flags indicating what events are enabled for colliders.\n */\nexport enum ActiveEvents {\n    NONE = 0,\n    /**\n     * Enable collision events.\n     */\n    COLLISION_EVENTS = 0b0001,\n    /**\n     * Enable contact force events.\n     */\n    CONTACT_FORCE_EVENTS = 0b0010,\n}\n\n/**\n * Event occurring when the sum of the magnitudes of the\n * contact forces between two colliders exceed a threshold.\n *\n * This object should **not** be stored anywhere. Its properties can only be\n * read from within the closure given to `EventHandler.drainContactForceEvents`.\n */\nexport class TempContactForceEvent {\n    raw: RawContactForceEvent;\n\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    /**\n     * The first collider involved in the contact.\n     */\n    public collider1(): ColliderHandle {\n        return this.raw.collider1();\n    }\n\n    /**\n     * The second collider involved in the contact.\n     */\n    public collider2(): ColliderHandle {\n        return this.raw.collider2();\n    }\n\n    /**\n     * The sum of all the forces between the two colliders.\n     */\n    public totalForce(): Vector {\n        return VectorOps.fromRaw(this.raw.total_force());\n    }\n\n    /**\n     * The sum of the magnitudes of each force between the two colliders.\n     *\n     * Note that this is **not** the same as the magnitude of `self.total_force`.\n     * Here we are summing the magnitude of all the forces, instead of taking\n     * the magnitude of their sum.\n     */\n    public totalForceMagnitude(): number {\n        return this.raw.total_force_magnitude();\n    }\n\n    /**\n     * The world-space (unit) direction of the force with strongest magnitude.\n     */\n    public maxForceDirection(): Vector {\n        return VectorOps.fromRaw(this.raw.max_force_direction());\n    }\n\n    /**\n     * The magnitude of the largest force at a contact point of this contact pair.\n     */\n    public maxForceMagnitude(): number {\n        return this.raw.max_force_magnitude();\n    }\n}\n\n/**\n * A structure responsible for collecting events generated\n * by the physics engine.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `eventQueue.free()`\n * once you are done using it.\n */\nexport class EventQueue {\n    raw: RawEventQueue;\n\n    /**\n     * Creates a new event collector.\n     *\n     * @param autoDrain -setting this to `true` is strongly recommended. If true, the collector will\n     * be automatically drained before each `world.step(collector)`. If false, the collector will\n     * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n     * RAM if no drain is performed.\n     */\n    constructor(autoDrain: boolean, raw?: RawEventQueue) {\n        this.raw = raw || new RawEventQueue(autoDrain);\n    }\n\n    /**\n     * Release the WASM memory occupied by this event-queue.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    /**\n     * Applies the given javascript closure on each collision event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     * closure must take three arguments: two integers representing the handles of the colliders\n     * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n     * (false).\n     */\n    public drainCollisionEvents(\n        f: (\n            handle1: ColliderHandle,\n            handle2: ColliderHandle,\n            started: boolean,\n        ) => void,\n    ) {\n        this.raw.drainCollisionEvents(f);\n    }\n\n    /**\n     * Applies the given javascript closure on each contact force event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     *            closure must take one `TempContactForceEvent` argument.\n     */\n    public drainContactForceEvents(f: (event: TempContactForceEvent) => void) {\n        let event = new TempContactForceEvent();\n        this.raw.drainContactForceEvents((raw: RawContactForceEvent) => {\n            event.raw = raw;\n            f(event);\n            event.free();\n        });\n    }\n\n    /**\n     * Removes all events contained by this collector\n     */\n    public clear() {\n        this.raw.clear();\n    }\n}\n", "import {RigidBodyHandle} from \"../dynamics\";\nimport {ColliderHandle} from \"../geometry\";\n\nexport enum ActiveHooks {\n    NONE = 0,\n    FILTER_CONTACT_PAIRS = 0b0001,\n    FILTER_INTERSECTION_PAIRS = 0b0010,\n    // MODIFY_SOLVER_CONTACTS = 0b0100, /* Not supported yet in JS. */\n}\n\nexport enum SolverFlags {\n    EMPTY = 0b000,\n    COMPUTE_IMPULSE = 0b001,\n}\n\nexport interface PhysicsHooks {\n    /**\n     * Function that determines if contacts computation should happen between two colliders, and how the\n     * constraints solver should behave for these contacts.\n     *\n     * This will only be executed and taken into account if at least one of the involved colliders contains the\n     * `ActiveHooks.FILTER_CONTACT_PAIR` flag in its active hooks.\n     *\n     * @param collider1  Handle of the first collider involved in the potential contact.\n     * @param collider2  Handle of the second collider involved in the potential contact.\n     * @param body1  Handle of the first body involved in the potential contact.\n     * @param body2  Handle of the second body involved in the potential contact.\n     */\n    filterContactPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n        body1: RigidBodyHandle,\n        body2: RigidBodyHandle,\n    ): SolverFlags | null;\n\n    /**\n     * Function that determines if intersection computation should happen between two colliders (where at least\n     * one is a sensor).\n     *\n     * This will only be executed and taken into account if `one of the involved colliders contains the\n     * `ActiveHooks.FILTER_INTERSECTION_PAIR` flag in its active hooks.\n     *\n     * @param collider1  Handle of the first collider involved in the potential contact.\n     * @param collider2  Handle of the second collider involved in the potential contact.\n     * @param body1  Handle of the first body involved in the potential contact.\n     * @param body2  Handle of the second body involved in the potential contact.\n     */\n    filterIntersectionPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n        body1: RigidBodyHandle,\n        body2: RigidBodyHandle,\n    ): boolean;\n}\n", "import {RawColliderSet} from \"../raw\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\nimport {\n    CoefficientCombineRule,\n    RigidBody,\n    RigidBodyHandle,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {ActiveHooks, ActiveEvents} from \"../pipeline\";\nimport {InteractionGroups} from \"./interaction_groups\";\nimport {\n    Shape,\n    Cuboid,\n    Ball,\n    ShapeType,\n    Capsule,\n    TriMesh,\n    Polyline,\n    Heightfield,\n    Segment,\n    Triangle,\n    RoundTriangle,\n    RoundCuboid,\n    HalfSpace,\n    TriMeshFlags,\n    // #if DIM2\n    ConvexPolygon,\n    RoundConvexPolygon,\n    // #endif\n} from \"./shape\";\nimport {Ray, RayIntersection} from \"./ray\";\nimport {PointProjection} from \"./point\";\nimport {ColliderShapeCastHit, ShapeCastHit} from \"./toi\";\nimport {ShapeContact} from \"./contact\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * Flags affecting whether collision-detection happens between two colliders\n * depending on the type of rigid-bodies they are attached to.\n */\nexport enum ActiveCollisionTypes {\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a dynamic body.\n     */\n    DYNAMIC_DYNAMIC = 0b0000_0000_0000_0001,\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a kinematic body.\n     */\n    DYNAMIC_KINEMATIC = 0b0000_0000_0000_1100,\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    DYNAMIC_FIXED = 0b0000_0000_0000_0010,\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a kinematic body.\n     */\n    KINEMATIC_KINEMATIC = 0b1100_1100_0000_0000,\n\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    KINEMATIC_FIXED = 0b0010_0010_0000_0000,\n\n    /**\n     * Enable collision-detection between a collider attached to a fixed body (or\n     * not attached to any body) and another collider attached to a fixed body (or\n     * not attached to any body).\n     */\n    FIXED_FIXED = 0b0000_0000_0010_0000,\n    /**\n     * The default active collision types, enabling collisions between a dynamic body\n     * and another body of any type, but not enabling collisions between two non-dynamic bodies.\n     */\n    DEFAULT = DYNAMIC_KINEMATIC | DYNAMIC_DYNAMIC | DYNAMIC_FIXED,\n    /**\n     * Enable collisions between any kind of rigid-bodies (including between two non-dynamic bodies).\n     */\n    ALL = DYNAMIC_KINEMATIC |\n        DYNAMIC_DYNAMIC |\n        DYNAMIC_FIXED |\n        KINEMATIC_KINEMATIC |\n        KINEMATIC_FIXED |\n        KINEMATIC_KINEMATIC,\n}\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type ColliderHandle = number;\n\n/**\n * A geometric entity that can be attached to a body so it can be affected\n * by contacts and proximity queries.\n */\nexport class Collider {\n    private colliderSet: ColliderSet; // The Collider won't need to free this.\n    readonly handle: ColliderHandle;\n    private _shape: Shape;\n    private _parent: RigidBody | null;\n\n    constructor(\n        colliderSet: ColliderSet,\n        handle: ColliderHandle,\n        parent: RigidBody | null,\n        shape?: Shape,\n    ) {\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n        this._parent = parent;\n        this._shape = shape;\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodies: RigidBodySet) {\n        if (this.handle != null) {\n            this._parent = bodies.get(\n                this.colliderSet.raw.coParent(this.handle),\n            );\n        }\n    }\n\n    private ensureShapeIsCached() {\n        if (!this._shape)\n            this._shape = Shape.fromRaw(this.colliderSet.raw, this.handle);\n    }\n\n    /**\n     * The shape of this collider.\n     */\n    public get shape(): Shape {\n        this.ensureShapeIsCached();\n        return this._shape;\n    }\n\n    /**\n     * Checks if this collider is still valid (i.e. that it has\n     * not been deleted from the collider set yet).\n     */\n    public isValid(): boolean {\n        return this.colliderSet.raw.contains(this.handle);\n    }\n\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    public translation(): Vector {\n        return VectorOps.fromRaw(\n            this.colliderSet.raw.coTranslation(this.handle),\n        );\n    }\n\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    public rotation(): Rotation {\n        return RotationOps.fromRaw(\n            this.colliderSet.raw.coRotation(this.handle),\n        );\n    }\n\n    /**\n     * Is this collider a sensor?\n     */\n    public isSensor(): boolean {\n        return this.colliderSet.raw.coIsSensor(this.handle);\n    }\n\n    /**\n     * Sets whether or not this collider is a sensor.\n     * @param isSensor - If `true`, the collider will be a sensor.\n     */\n    public setSensor(isSensor: boolean) {\n        this.colliderSet.raw.coSetSensor(this.handle, isSensor);\n    }\n\n    /**\n     * Sets the new shape of the collider.\n     * @param shape - The colliders new shape.\n     */\n    public setShape(shape: Shape) {\n        let rawShape = shape.intoRaw();\n        this.colliderSet.raw.coSetShape(this.handle, rawShape);\n        rawShape.free();\n        this._shape = shape;\n    }\n\n    /**\n     * Sets whether this collider is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this collider (its parent rigid-body wont be disabled automatically by this).\n     */\n    public setEnabled(enabled: boolean) {\n        this.colliderSet.raw.coSetEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Is this collider enabled?\n     */\n    public isEnabled(): boolean {\n        return this.colliderSet.raw.coIsEnabled(this.handle);\n    }\n\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    public setRestitution(restitution: number) {\n        this.colliderSet.raw.coSetRestitution(this.handle, restitution);\n    }\n\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    public setFriction(friction: number) {\n        this.colliderSet.raw.coSetFriction(this.handle, friction);\n    }\n\n    /**\n     * Gets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    public frictionCombineRule(): CoefficientCombineRule {\n        return this.colliderSet.raw.coFrictionCombineRule(this.handle);\n    }\n\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    public setFrictionCombineRule(rule: CoefficientCombineRule) {\n        this.colliderSet.raw.coSetFrictionCombineRule(this.handle, rule);\n    }\n\n    /**\n     * Gets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    public restitutionCombineRule(): CoefficientCombineRule {\n        return this.colliderSet.raw.coRestitutionCombineRule(this.handle);\n    }\n\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    public setRestitutionCombineRule(rule: CoefficientCombineRule) {\n        this.colliderSet.raw.coSetRestitutionCombineRule(this.handle, rule);\n    }\n\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    public setCollisionGroups(groups: InteractionGroups) {\n        this.colliderSet.raw.coSetCollisionGroups(this.handle, groups);\n    }\n\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    public setSolverGroups(groups: InteractionGroups) {\n        this.colliderSet.raw.coSetSolverGroups(this.handle, groups);\n    }\n\n    /**\n     * Sets the contact skin for this collider.\n     *\n     * See the documentation of `ColliderDesc.setContactSkin` for additional details.\n     */\n    public contactSkin(): number {\n        return this.colliderSet.raw.coContactSkin(this.handle);\n    }\n\n    /**\n     * Sets the contact skin for this collider.\n     *\n     * See the documentation of `ColliderDesc.setContactSkin` for additional details.\n     *\n     * @param thickness - The contact skin thickness.\n     */\n    public setContactSkin(thickness: number) {\n        return this.colliderSet.raw.coSetContactSkin(this.handle, thickness);\n    }\n\n    /**\n     * Get the physics hooks active for this collider.\n     */\n    public activeHooks(): ActiveHooks {\n        return this.colliderSet.raw.coActiveHooks(this.handle);\n    }\n\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveHooks(activeHooks: ActiveHooks) {\n        this.colliderSet.raw.coSetActiveHooks(this.handle, activeHooks);\n    }\n\n    /**\n     * The events active for this collider.\n     */\n    public activeEvents(): ActiveEvents {\n        return this.colliderSet.raw.coActiveEvents(this.handle);\n    }\n\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    public setActiveEvents(activeEvents: ActiveEvents) {\n        this.colliderSet.raw.coSetActiveEvents(this.handle, activeEvents);\n    }\n\n    /**\n     * Gets the collision types active for this collider.\n     */\n    public activeCollisionTypes(): ActiveCollisionTypes {\n        return this.colliderSet.raw.coActiveCollisionTypes(this.handle);\n    }\n\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The new force threshold.\n     */\n    public setContactForceEventThreshold(threshold: number) {\n        return this.colliderSet.raw.coSetContactForceEventThreshold(\n            this.handle,\n            threshold,\n        );\n    }\n\n    /**\n     * The total force magnitude beyond which a contact force event can be emitted.\n     */\n    public contactForceEventThreshold(): number {\n        return this.colliderSet.raw.coContactForceEventThreshold(this.handle);\n    }\n\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveCollisionTypes(activeCollisionTypes: ActiveCollisionTypes) {\n        this.colliderSet.raw.coSetActiveCollisionTypes(\n            this.handle,\n            activeCollisionTypes,\n        );\n    }\n\n    /**\n     * Sets the uniform density of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The mass and angular inertia of this collider will be computed automatically based on its\n     * shape.\n     */\n    public setDensity(density: number) {\n        this.colliderSet.raw.coSetDensity(this.handle, density);\n    }\n\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The angular inertia of this collider will be computed automatically based on its shape\n     * and this mass value.\n     */\n    public setMass(mass: number) {\n        this.colliderSet.raw.coSetMass(this.handle, mass);\n    }\n\n\n    // #if DIM2\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     */\n    public setMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: number,\n    ) {\n        let rawCom = VectorOps.intoRaw(centerOfMass);\n        this.colliderSet.raw.coSetMassProperties(\n            this.handle,\n            mass,\n            rawCom,\n            principalAngularInertia,\n        );\n        rawCom.free();\n    }\n\n    // #endif\n\n    /**\n     * Sets the translation of this collider.\n     *\n     * @param tra - The world-space position of the collider.\n     */\n    public setTranslation(tra: Vector) {\n        // #if DIM2\n        this.colliderSet.raw.coSetTranslation(this.handle, tra.x, tra.y);\n        // #endif\n    }\n\n    /**\n     * Sets the translation of this collider relative to its parent rigid-body.\n     *\n     * Does nothing if this collider isn't attached to a rigid-body.\n     *\n     * @param tra - The new translation of the collider relative to its parent.\n     */\n    public setTranslationWrtParent(tra: Vector) {\n        // #if DIM2\n        this.colliderSet.raw.coSetTranslationWrtParent(\n            this.handle,\n            tra.x,\n            tra.y,\n        );\n        // #endif\n    }\n\n    // #if DIM2\n    /**\n     * Sets the rotation angle of this collider.\n     *\n     * @param angle - The rotation angle, in radians.\n     */\n    public setRotation(angle: number) {\n        this.colliderSet.raw.coSetRotation(this.handle, angle);\n    }\n\n    /**\n     * Sets the rotation angle of this collider relative to its parent rigid-body.\n     *\n     * Does nothing if this collider isn't attached to a rigid-body.\n     *\n     * @param angle - The rotation angle, in radians.\n     */\n    public setRotationWrtParent(angle: number) {\n        this.colliderSet.raw.coSetRotationWrtParent(this.handle, angle);\n    }\n\n    // #endif\n\n    /**\n     * The type of the shape of this collider.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public shapeType(): ShapeType {\n        return this.colliderSet.raw.coShapeType(\n            this.handle,\n        ) as number as ShapeType;\n    }\n\n    /**\n     * The half-extents of this collider if it is a cuboid shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public halfExtents(): Vector {\n        return VectorOps.fromRaw(\n            this.colliderSet.raw.coHalfExtents(this.handle),\n        );\n    }\n\n    /**\n     * Sets the half-extents of this collider if it is a cuboid shape.\n     *\n     * @param newHalfExtents - desired half extents.\n     */\n    public setHalfExtents(newHalfExtents: Vector) {\n        const rawPoint = VectorOps.intoRaw(newHalfExtents);\n        this.colliderSet.raw.coSetHalfExtents(this.handle, rawPoint);\n    }\n\n    /**\n     * The radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public radius(): number {\n        return this.colliderSet.raw.coRadius(this.handle);\n    }\n\n    /**\n     * Sets the radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     *\n     * @param newRadius - desired radius.\n     */\n    public setRadius(newRadius: number): void {\n        this.colliderSet.raw.coSetRadius(this.handle, newRadius);\n    }\n\n    /**\n     * The radius of the round edges of this collider if it is a round cylinder.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public roundRadius(): number {\n        return this.colliderSet.raw.coRoundRadius(this.handle);\n    }\n\n    /**\n     * Sets the radius of the round edges of this collider if it has round edges.\n     *\n     * @param newBorderRadius - desired round edge radius.\n     */\n    public setRoundRadius(newBorderRadius: number) {\n        this.colliderSet.raw.coSetRoundRadius(this.handle, newBorderRadius);\n    }\n\n    /**\n     * The half height of this collider if it is a cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public halfHeight(): number {\n        return this.colliderSet.raw.coHalfHeight(this.handle);\n    }\n\n    /**\n     * Sets the half height of this collider if it is a cylinder, capsule, or cone shape.\n     *\n     * @param newHalfheight - desired half height.\n     */\n    public setHalfHeight(newHalfheight: number) {\n        this.colliderSet.raw.coSetHalfHeight(this.handle, newHalfheight);\n    }\n\n    /**\n     * If this collider has a triangle mesh, polyline, convex polygon, or convex polyhedron shape,\n     * this returns the vertex buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public vertices(): Float32Array {\n        return this.colliderSet.raw.coVertices(this.handle);\n    }\n\n    /**\n     * If this collider has a triangle mesh, polyline, or convex polyhedron shape,\n     * this returns the index buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public indices(): Uint32Array | undefined {\n        return this.colliderSet.raw.coIndices(this.handle);\n    }\n\n    /**\n     * If this collider has a heightfield shape, this returns the heights buffer of\n     * the heightfield.\n     * In 3D, the returned height matrix is provided in column-major order.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public heightfieldHeights(): Float32Array {\n        return this.colliderSet.raw.coHeightfieldHeights(this.handle);\n    }\n\n    /**\n     * If this collider has a heightfield shape, this returns the scale\n     * applied to it.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public heightfieldScale(): Vector {\n        let scale = this.colliderSet.raw.coHeightfieldScale(this.handle);\n        return VectorOps.fromRaw(scale);\n    }\n\n\n    /**\n     * The rigid-body this collider is attached to.\n     */\n    public parent(): RigidBody | null {\n        return this._parent;\n    }\n\n    /**\n     * The friction coefficient of this collider.\n     */\n    public friction(): number {\n        return this.colliderSet.raw.coFriction(this.handle);\n    }\n\n    /**\n     * The restitution coefficient of this collider.\n     */\n    public restitution(): number {\n        return this.colliderSet.raw.coRestitution(this.handle);\n    }\n\n    /**\n     * The density of this collider.\n     */\n    public density(): number {\n        return this.colliderSet.raw.coDensity(this.handle);\n    }\n\n    /**\n     * The mass of this collider.\n     */\n    public mass(): number {\n        return this.colliderSet.raw.coMass(this.handle);\n    }\n\n    /**\n     * The volume of this collider.\n     */\n    public volume(): number {\n        return this.colliderSet.raw.coVolume(this.handle);\n    }\n\n    /**\n     * The collision groups of this collider.\n     */\n    public collisionGroups(): InteractionGroups {\n        return this.colliderSet.raw.coCollisionGroups(this.handle);\n    }\n\n    /**\n     * The solver groups of this collider.\n     */\n    public solverGroups(): InteractionGroups {\n        return this.colliderSet.raw.coSolverGroups(this.handle);\n    }\n\n    /**\n     * Tests if this collider contains a point.\n     *\n     * @param point - The point to test.\n     */\n    public containsPoint(point: Vector): boolean {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = this.colliderSet.raw.coContainsPoint(\n            this.handle,\n            rawPoint,\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Find the projection of a point on this collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     */\n    public projectPoint(point: Vector, solid: boolean): PointProjection | null {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointProjection.fromRaw(\n            this.colliderSet.raw.coProjectPoint(this.handle, rawPoint, solid),\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Tests if this collider intersects the given ray.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     */\n    public intersectsRay(ray: Ray, maxToi: number): boolean {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coIntersectsRay(\n            this.handle,\n            rawOrig,\n            rawDir,\n            maxToi,\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /*\n     * Computes the smallest time between this and the given shape under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current shape to cast (i.e. the cast direction).\n     * @param shape2 - The shape to cast against.\n     * @param shape2Pos - The position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param shape2Vel - The constant velocity of the second shape.\n     * @param targetDistance  If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `collider1Vel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     */\n    public castShape(\n        collider1Vel: Vector,\n        shape2: Shape,\n        shape2Pos: Vector,\n        shape2Rot: Rotation,\n        shape2Vel: Vector,\n        targetDistance: number,\n        maxToi: number,\n        stopAtPenetration: boolean,\n    ): ShapeCastHit | null {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawShape2Pos = VectorOps.intoRaw(shape2Pos);\n        let rawShape2Rot = RotationOps.intoRaw(shape2Rot);\n        let rawShape2Vel = VectorOps.intoRaw(shape2Vel);\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeCastHit.fromRaw(\n            this.colliderSet,\n            this.colliderSet.raw.coCastShape(\n                this.handle,\n                rawCollider1Vel,\n                rawShape2,\n                rawShape2Pos,\n                rawShape2Rot,\n                rawShape2Vel,\n                targetDistance,\n                maxToi,\n                stopAtPenetration,\n            ),\n        );\n\n        rawCollider1Vel.free();\n        rawShape2Pos.free();\n        rawShape2Rot.free();\n        rawShape2Vel.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /*\n     * Computes the smallest time between this and the given collider under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current collider to cast (i.e. the cast direction).\n     * @param collider2 - The collider to cast against.\n     * @param collider2Vel - The constant velocity of the second collider.\n     * @param targetDistance  If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     */\n    public castCollider(\n        collider1Vel: Vector,\n        collider2: Collider,\n        collider2Vel: Vector,\n        targetDistance: number,\n        maxToi: number,\n        stopAtPenetration: boolean,\n    ): ColliderShapeCastHit | null {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawCollider2Vel = VectorOps.intoRaw(collider2Vel);\n\n        let result = ColliderShapeCastHit.fromRaw(\n            this.colliderSet,\n            this.colliderSet.raw.coCastCollider(\n                this.handle,\n                rawCollider1Vel,\n                collider2.handle,\n                rawCollider2Vel,\n                targetDistance,\n                maxToi,\n                stopAtPenetration,\n            ),\n        );\n\n        rawCollider1Vel.free();\n        rawCollider2Vel.free();\n\n        return result;\n    }\n\n    public intersectsShape(\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n    ): boolean {\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawShape2 = shape2.intoRaw();\n\n        let result = this.colliderSet.raw.coIntersectsShape(\n            this.handle,\n            rawShape2,\n            rawPos2,\n            rawRot2,\n        );\n\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Computes one pair of contact points between the shape owned by this collider and the given shape.\n     *\n     * @param shape2 - The second shape.\n     * @param shape2Pos - The initial position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(\n        shape2: Shape,\n        shape2Pos: Vector,\n        shape2Rot: Rotation,\n        prediction: number,\n    ): ShapeContact | null {\n        let rawPos2 = VectorOps.intoRaw(shape2Pos);\n        let rawRot2 = RotationOps.intoRaw(shape2Rot);\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeContact.fromRaw(\n            this.colliderSet.raw.coContactShape(\n                this.handle,\n                rawShape2,\n                rawPos2,\n                rawRot2,\n                prediction,\n            ),\n        );\n\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Computes one pair of contact points between the collider and the given collider.\n     *\n     * @param collider2 - The second collider.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactCollider(\n        collider2: Collider,\n        prediction: number,\n    ): ShapeContact | null {\n        let result = ShapeContact.fromRaw(\n            this.colliderSet.raw.coContactCollider(\n                this.handle,\n                collider2.handle,\n                prediction,\n            ),\n        );\n\n        return result;\n    }\n\n    /**\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @returns The time-of-impact between this collider and the ray, or `-1` if there is no intersection.\n     */\n    public castRay(ray: Ray, maxToi: number, solid: boolean): number {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coCastRay(\n            this.handle,\n            rawOrig,\n            rawDir,\n            maxToi,\n            solid,\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /**\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     */\n    public castRayAndGetNormal(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n    ): RayIntersection | null {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayIntersection.fromRaw(\n            this.colliderSet.raw.coCastRayAndGetNormal(\n                this.handle,\n                rawOrig,\n                rawDir,\n                maxToi,\n                solid,\n            ),\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n}\n\nexport enum MassPropsMode {\n    Density,\n    Mass,\n    MassProps,\n}\n\nexport class ColliderDesc {\n    enabled: boolean;\n    shape: Shape;\n    massPropsMode: MassPropsMode;\n    mass: number;\n    centerOfMass: Vector;\n    // #if DIM2\n    principalAngularInertia: number;\n    rotationsEnabled: boolean;\n    // #endif\n    density: number;\n    friction: number;\n    restitution: number;\n    rotation: Rotation;\n    translation: Vector;\n    isSensor: boolean;\n    collisionGroups: InteractionGroups;\n    solverGroups: InteractionGroups;\n    frictionCombineRule: CoefficientCombineRule;\n    restitutionCombineRule: CoefficientCombineRule;\n    activeEvents: ActiveEvents;\n    activeHooks: ActiveHooks;\n    activeCollisionTypes: ActiveCollisionTypes;\n    contactForceEventThreshold: number;\n    contactSkin: number;\n\n    /**\n     * Initializes a collider descriptor from the collision shape.\n     *\n     * @param shape - The shape of the collider being built.\n     */\n    constructor(shape: Shape) {\n        this.enabled = true;\n        this.shape = shape;\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = 1.0;\n        this.friction = 0.5;\n        this.restitution = 0.0;\n        this.rotation = RotationOps.identity();\n        this.translation = VectorOps.zeros();\n        this.isSensor = false;\n        this.collisionGroups = 0xffff_ffff;\n        this.solverGroups = 0xffff_ffff;\n        this.frictionCombineRule = CoefficientCombineRule.Average;\n        this.restitutionCombineRule = CoefficientCombineRule.Average;\n        this.activeCollisionTypes = ActiveCollisionTypes.DEFAULT;\n        this.activeEvents = ActiveEvents.NONE;\n        this.activeHooks = ActiveHooks.NONE;\n        this.mass = 0.0;\n        this.centerOfMass = VectorOps.zeros();\n        this.contactForceEventThreshold = 0.0;\n        this.contactSkin = 0.0;\n\n        // #if DIM2\n        this.principalAngularInertia = 0.0;\n        this.rotationsEnabled = true;\n        // #endif\n    }\n\n    /**\n     * Create a new collider descriptor with a ball shape.\n     *\n     * @param radius - The radius of the ball.\n     */\n    public static ball(radius: number): ColliderDesc {\n        const shape = new Ball(radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a capsule shape.\n     *\n     * @param halfHeight - The half-height of the capsule, along the `y` axis.\n     * @param radius - The radius of the capsule basis.\n     */\n    public static capsule(halfHeight: number, radius: number): ColliderDesc {\n        const shape = new Capsule(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new segment shape.\n     *\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    public static segment(a: Vector, b: Vector): ColliderDesc {\n        const shape = new Segment(a, b);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    public static triangle(a: Vector, b: Vector, c: Vector): ColliderDesc {\n        const shape = new Triangle(a, b, c);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    public static roundTriangle(\n        a: Vector,\n        b: Vector,\n        c: Vector,\n        borderRadius: number,\n    ): ColliderDesc {\n        const shape = new RoundTriangle(a, b, c, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `undefined` or `null`,\n     *    the vertices are assumed to describe a line strip.\n     */\n    public static polyline(\n        vertices: Float32Array,\n        indices?: Uint32Array | null,\n    ): ColliderDesc {\n        const shape = new Polyline(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    public static trimesh(\n        vertices: Float32Array,\n        indices: Uint32Array,\n        flags?: TriMeshFlags,\n    ): ColliderDesc {\n        const shape = new TriMesh(vertices, indices, flags);\n        return new ColliderDesc(shape);\n    }\n\n    // #if DIM2\n    /**\n     * Creates a new collider descriptor with a rectangular shape.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     */\n    public static cuboid(hx: number, hy: number): ColliderDesc {\n        const shape = new Cuboid(hx, hy);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a rectangular shape with round borders.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param borderRadius - The radius of the cuboid's borders.\n     */\n    public static roundCuboid(\n        hx: number,\n        hy: number,\n        borderRadius: number,\n    ): ColliderDesc {\n        const shape = new RoundCuboid(hx, hy, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider description with a halfspace (infinite plane) shape.\n     *\n     * @param normal - The outward normal of the plane.\n     */\n    public static halfspace(normal: Vector): ColliderDesc {\n        const shape = new HalfSpace(normal);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a heightfield shape.\n     *\n     * @param heights - The heights of the heightfield, along its local `y` axis.\n     * @param scale - The scale factor applied to the heightfield.\n     */\n    public static heightfield(\n        heights: Float32Array,\n        scale: Vector,\n    ): ColliderDesc {\n        const shape = new Heightfield(heights, scale);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polygon as the shape for this new collider descriptor.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     */\n    public static convexHull(points: Float32Array): ColliderDesc | null {\n        const shape = new ConvexPolygon(points, false);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     */\n    public static convexPolyline(vertices: Float32Array): ColliderDesc | null {\n        const shape = new ConvexPolygon(vertices, true);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polygon as the shape for this new collider descriptor. A\n     * border is added to that convex polygon to give it round corners.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     * @param borderRadius - The radius of the round border added to the convex polygon.\n     */\n    public static roundConvexHull(\n        points: Float32Array,\n        borderRadius: number,\n    ): ColliderDesc | null {\n        const shape = new RoundConvexPolygon(points, borderRadius, false);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a round convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     * @param borderRadius - The radius of the round border added to the convex polyline.\n     */\n    public static roundConvexPolyline(\n        vertices: Float32Array,\n        borderRadius: number,\n    ): ColliderDesc | null {\n        const shape = new RoundConvexPolygon(vertices, borderRadius, true);\n        return new ColliderDesc(shape);\n    }\n\n    // #endif\n\n\n    // #if DIM2\n    /**\n     * Sets the position of the collider to be created relative to the rigid-body it is attached to.\n     */\n    public setTranslation(x: number, y: number): ColliderDesc {\n        if (typeof x != \"number\" || typeof y != \"number\")\n            throw TypeError(\"The translation components must be numbers.\");\n\n        this.translation = {x: x, y: y};\n        return this;\n    }\n\n    // #endif\n\n\n    /**\n     * Sets the rotation of the collider to be created relative to the rigid-body it is attached to.\n     *\n     * @param rot - The rotation of the collider to be created relative to the rigid-body it is attached to.\n     */\n    public setRotation(rot: Rotation): ColliderDesc {\n        // #if DIM2\n        this.rotation = rot;\n        // #endif\n        return this;\n    }\n\n    /**\n     * Sets whether or not the collider being created is a sensor.\n     *\n     * A sensor collider does not take part of the physics simulation, but generates\n     * proximity events.\n     *\n     * @param sensor - Set to `true` of the collider built is to be a sensor.\n     */\n    public setSensor(sensor: boolean): ColliderDesc {\n        this.isSensor = sensor;\n        return this;\n    }\n\n    /**\n     * Sets whether the created collider will be enabled or disabled.\n     * @param enabled  If set to `false` the collider will be disabled at creation.\n     */\n    public setEnabled(enabled: boolean): ColliderDesc {\n        this.enabled = enabled;\n        return this;\n    }\n\n    /**\n     * Sets the contact skin of the collider.\n     *\n     * The contact skin acts as if the collider was enlarged with a skin of width `skin_thickness`\n     * around it, keeping objects further apart when colliding.\n     *\n     * A non-zero contact skin can increase performance, and in some cases, stability. However\n     * it creates a small gap between colliding object (equal to the sum of their skin). If the\n     * skin is sufficiently small, this might not be visually significant or can be hidden by the\n     * rendering assets.\n     */\n    public setContactSkin(thickness: number): ColliderDesc {\n        this.contactSkin = thickness;\n        return this;\n    }\n\n    /**\n     * Sets the density of the collider being built.\n     *\n     * The mass and angular inertia tensor will be computed automatically based on this density and the colliders shape.\n     *\n     * @param density - The density to set, must be greater or equal to 0. A density of 0 means that this collider\n     *                  will not affect the mass or angular inertia of the rigid-body it is attached to.\n     */\n    public setDensity(density: number): ColliderDesc {\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = density;\n        return this;\n    }\n\n    /**\n     * Sets the mass of the collider being built.\n     *\n     * The angular inertia tensor will be computed automatically based on this mass and the colliders shape.\n     *\n     * @param mass - The mass to set, must be greater or equal to 0.\n     */\n    public setMass(mass: number): ColliderDesc {\n        this.massPropsMode = MassPropsMode.Mass;\n        this.mass = mass;\n        return this;\n    }\n\n    // #if DIM2\n    /**\n     * Sets the mass properties of the collider being built.\n     *\n     * This replaces the mass-properties automatically computed from the collider's density and shape.\n     * These mass-properties will be added to the mass-properties of the rigid-body this collider will be attached to.\n     *\n     * @param mass  The mass of the collider to create.\n     * @param centerOfMass  The center-of-mass of the collider to create.\n     * @param principalAngularInertia  The principal angular inertia of the collider to create.\n     */\n    public setMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: number,\n    ): ColliderDesc {\n        this.massPropsMode = MassPropsMode.MassProps;\n        this.mass = mass;\n        VectorOps.copy(this.centerOfMass, centerOfMass);\n        this.principalAngularInertia = principalAngularInertia;\n        return this;\n    }\n\n    // #endif\n\n\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    public setRestitution(restitution: number): ColliderDesc {\n        this.restitution = restitution;\n        return this;\n    }\n\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    public setFriction(friction: number): ColliderDesc {\n        this.friction = friction;\n        return this;\n    }\n\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    public setFrictionCombineRule(rule: CoefficientCombineRule): ColliderDesc {\n        this.frictionCombineRule = rule;\n        return this;\n    }\n\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    public setRestitutionCombineRule(\n        rule: CoefficientCombineRule,\n    ): ColliderDesc {\n        this.restitutionCombineRule = rule;\n        return this;\n    }\n\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    public setCollisionGroups(groups: InteractionGroups): ColliderDesc {\n        this.collisionGroups = groups;\n        return this;\n    }\n\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    public setSolverGroups(groups: InteractionGroups): ColliderDesc {\n        this.solverGroups = groups;\n        return this;\n    }\n\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveHooks(activeHooks: ActiveHooks): ColliderDesc {\n        this.activeHooks = activeHooks;\n        return this;\n    }\n\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    public setActiveEvents(activeEvents: ActiveEvents): ColliderDesc {\n        this.activeEvents = activeEvents;\n        return this;\n    }\n\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveCollisionTypes(\n        activeCollisionTypes: ActiveCollisionTypes,\n    ): ColliderDesc {\n        this.activeCollisionTypes = activeCollisionTypes;\n        return this;\n    }\n\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The force threshold to set.\n     */\n    public setContactForceEventThreshold(threshold: number): ColliderDesc {\n        this.contactForceEventThreshold = threshold;\n        return this;\n    }\n}\n", "import {RawColliderSet} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {RotationOps, VectorOps} from \"../math\";\nimport {Collider, ColliderDesc, ColliderHandle} from \"./collider\";\nimport {ImpulseJointHandle, IslandManager, RigidBodyHandle} from \"../dynamics\";\nimport {RigidBodySet} from \"../dynamics\";\n\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `colliderSet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class ColliderSet {\n    raw: RawColliderSet;\n    private map: Coarena<Collider>;\n\n    /**\n     * Release the WASM memory occupied by this collider set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawColliderSet) {\n        this.raw = raw || new RawColliderSet();\n        this.map = new Coarena<Collider>();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachColliderHandle((handle: ColliderHandle) => {\n                this.map.set(handle, new Collider(this, handle, null));\n            });\n        }\n    }\n\n    /** @internal */\n    public castClosure<Res>(\n        f?: (collider: Collider) => Res,\n    ): (handle: ColliderHandle) => Res | undefined {\n        return (handle) => {\n            if (!!f) {\n                return f(this.get(handle));\n            } else {\n                return undefined;\n            }\n        };\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodies: RigidBodySet) {\n        this.map.forEach((collider) =>\n            collider.finalizeDeserialization(bodies),\n        );\n    }\n\n    /**\n     * Creates a new collider and return its integer handle.\n     *\n     * @param bodies - The set of bodies where the collider's parent can be found.\n     * @param desc - The collider's description.\n     * @param parentHandle - The integer handle of the rigid-body this collider is attached to.\n     */\n    public createCollider(\n        bodies: RigidBodySet,\n        desc: ColliderDesc,\n        parentHandle: RigidBodyHandle,\n    ): Collider {\n        let hasParent = parentHandle != undefined && parentHandle != null;\n\n        if (hasParent && isNaN(parentHandle))\n            throw Error(\n                \"Cannot create a collider with a parent rigid-body handle that is not a number.\",\n            );\n\n        let rawShape = desc.shape.intoRaw();\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n\n\n        let handle = this.raw.createCollider(\n            desc.enabled,\n            rawShape,\n            rawTra,\n            rawRot,\n            desc.massPropsMode,\n            desc.mass,\n            rawCom,\n            // #if DIM2\n            desc.principalAngularInertia,\n            // #endif\n            desc.density,\n            desc.friction,\n            desc.restitution,\n            desc.frictionCombineRule,\n            desc.restitutionCombineRule,\n            desc.isSensor,\n            desc.collisionGroups,\n            desc.solverGroups,\n            desc.activeCollisionTypes,\n            desc.activeHooks,\n            desc.activeEvents,\n            desc.contactForceEventThreshold,\n            desc.contactSkin,\n            hasParent,\n            hasParent ? parentHandle : 0,\n            bodies.raw,\n        );\n\n        rawShape.free();\n        rawTra.free();\n        rawRot.free();\n        rawCom.free();\n\n\n        let parent = hasParent ? bodies.get(parentHandle) : null;\n        let collider = new Collider(this, handle, parent, desc.shape);\n        this.map.set(handle, collider);\n        return collider;\n    }\n\n    /**\n     * Remove a collider from this set.\n     *\n     * @param handle - The integer handle of the collider to remove.\n     * @param bodies - The set of rigid-body containing the rigid-body the collider is attached to.\n     * @param wakeUp - If `true`, the rigid-body the removed collider is attached to will be woken-up automatically.\n     */\n    public remove(\n        handle: ColliderHandle,\n        islands: IslandManager,\n        bodies: RigidBodySet,\n        wakeUp: boolean,\n    ) {\n        this.raw.remove(handle, islands.raw, bodies.raw, wakeUp);\n        this.unmap(handle);\n    }\n\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    public unmap(handle: ImpulseJointHandle) {\n        this.map.delete(handle);\n    }\n\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    public get(handle: ColliderHandle): Collider | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * The number of colliders on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a collider with the given handle?\n     *\n     * @param handle - The collider handle to check.\n     */\n    public contains(handle: ColliderHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Applies the given closure to each collider contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (collider: Collider) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Gets all colliders in the list.\n     *\n     * @returns collider list.\n     */\n    public getAll(): Collider[] {\n        return this.map.getAll();\n    }\n}\n", "import * as RAPIER from \"./exports\";\nexport * from \"./exports\";\nexport default RAPIER;\n"],
  "mappings": "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",
  "names": ["version", "wasm", "wasm", "RigidBodyType", "handle", "JointType", "MotorModel", "JointAxesMask", "CoefficientCombineRule", "FeatureType", "ShapeType", "TriMeshFlags", "QueryFilterFlags", "ActiveEvents", "ActiveHooks", "SolverFlags", "ActiveCollisionTypes", "MassPropsMode", "version"]
}
